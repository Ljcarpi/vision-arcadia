<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>2D Runner – Triple Jump+</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --ui-bg: #0b1020;
      --card-bg: #151a30;
      --accent: #ffca28;
      --accent-soft: rgba(255, 202, 40, 0.2);
      --danger: #ff5252;
      --text-main: #f5f5f5;
      --text-muted: #b0bec5;
    }

    * {
      box-sizing: border-box;
      padding: 0;
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
    }

    body {
      background: radial-gradient(circle at top, #283593 0, #0b1020 55%);
      min-height: 100vh;
      color: var(--text-main);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .wrapper {
      width: 100%;
      max-width: 1300px;
      padding: 16px;
    }

    .screen {
      background: linear-gradient(145deg, #151a30 0, #111425 60%, #03040b 100%);
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
      padding: 24px 18px 20px;
      display: none;
      min-height: min(95vh, 780px);
      position: relative;
      overflow: hidden;
    }

    .screen.active {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .screen-header {
      text-align: center;
      margin-bottom: 24px;
    }

    .screen-header h1 {
      font-size: 2rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      margin-bottom: 0.25rem;
      color: var(--accent);
      text-shadow: 0 0 12px rgba(255, 202, 40, 0.5);
    }

    .screen-header p {
      font-size: 0.95rem;
      color: var(--text-muted);
    }

    .menu-card {
      background: radial-gradient(circle at top left, #243b6b 0, #151a30 48%);
      border-radius: 18px;
      padding: 18px;
      max-width: 420px;
      width: 100%;
      border: 1px solid rgba(255, 255, 255, 0.07);
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.5);
    }

    .menu-section + .menu-section {
      margin-top: 18px;
      padding-top: 18px;
      border-top: 1px dashed rgba(255, 255, 255, 0.12);
    }

    .menu-section-title {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-muted);
      margin-bottom: 10px;
    }

    .btn {
      border: none;
      border-radius: 999px;
      padding: 10px 18px;
      font-size: 1rem;
      cursor: pointer;
      color: #10131f;
      background: linear-gradient(135deg, #ffca28, #ffeb3b);
      box-shadow: 0 8px 18px rgba(255, 202, 40, 0.45);
      font-weight: 600;
      transition:
        transform 0.12s ease,
        box-shadow 0.12s ease,
        filter 0.12s ease,
        background 0.15s ease;
      width: 100%;
      text-align: center;
    }

    .btn:hover {
      transform: translateY(-1px);
      filter: brightness(1.05);
      box-shadow: 0 10px 24px rgba(255, 202, 40, 0.6);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow: 0 6px 16px rgba(255, 202, 40, 0.5);
    }

    .btn-ghost {
      background: transparent;
      color: var(--accent);
      border: 1px solid rgba(255, 202, 40, 0.6);
      box-shadow: none;
    }

    .btn-ghost:hover {
      background: rgba(255, 202, 40, 0.09);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.6);
    }

    .difficulty-toggle {
      display: flex;
      gap: 6px;
      background: rgba(5, 10, 25, 0.9);
      padding: 4px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.07);
    }

    .difficulty-btn {
      flex: 1;
      border-radius: 999px;
      border: none;
      padding: 6px 0;
      font-size: 0.8rem;
      cursor: pointer;
      background: transparent;
      color: var(--text-muted);
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      transition:
        background 0.15s ease,
        color 0.15s ease,
        box-shadow 0.15s ease;
    }

    .difficulty-btn.active {
      background: linear-gradient(135deg, #ffca28, #ffb300);
      color: #10131f;
      box-shadow: 0 4px 14px rgba(255, 202, 40, 0.5);
    }

    .menu-main-buttons {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 6px;
    }

    .helper-text {
      font-size: 0.78rem;
      color: var(--text-muted);
      margin-top: 8px;
    }

    /* Instructions */

    #instructions .content {
      max-width: 560px;
      width: 100%;
      background: radial-gradient(circle at top, #263a6b 0, #151a30 50%);
      border-radius: 18px;
      padding: 18px 16px 16px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.5);
    }

    .instructions-grid {
      display: grid;
      gap: 12px;
      font-size: 0.9rem;
    }

    .instructions-grid h3 {
      font-size: 0.95rem;
      margin-bottom: 4px;
      color: var(--accent);
    }

    ul {
      padding-left: 16px;
      color: var(--text-muted);
    }

    li + li {
      margin-top: 4px;
    }

    .kbd {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 5px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(0, 0, 0, 0.4);
      font-size: 0.8rem;
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo,
        Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .instructions-footer {
      display: flex;
      justify-content: flex-end;
      margin-top: 16px;
      gap: 8px;
      flex-wrap: wrap;
    }

    /* Game */

    #gameContainer {
      padding: 14px 12px 14px;
      align-items: stretch;
      justify-content: flex-start;
      gap: 10px;
    }

    .hud {
      width: 100%;
      max-width: 1200px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin: 0 auto;
      padding: 6px 10px;
      border-radius: 999px;
      background: linear-gradient(
        120deg,
        rgba(3, 6, 18, 0.95),
        rgba(7, 12, 35, 0.98)
      );
      border: 1px solid rgba(255, 255, 255, 0.07);
    }

    .hud-left {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .hud-pill {
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.09em;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: rgba(0, 0, 0, 0.55);
      color: var(--text-muted);
    }

    .hud-pill strong {
      color: var(--accent);
      font-weight: 700;
    }

    .hud-pill.score {
      background: radial-gradient(circle at top, #ffca28 0, #f57f17 72%);
      color: #10131f;
      box-shadow: 0 0 20px rgba(255, 202, 40, 0.6);
    }

    .hud-pill.score strong {
      color: #10131f;
    }

    .hud-right {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.75rem;
      color: var(--text-muted);
      flex-wrap: wrap;
    }

    .hud-dot {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: #53e079;
      box-shadow: 0 0 8px rgba(83, 224, 121, 0.7);
    }

    #gameCanvas {
      margin: 8px auto 0;
      width: 100%;
      max-width: 1200px;
      border-radius: 18px;
      display: block;
      background: #7ec8ff;
      border: 1px solid rgba(255, 255, 255, 0.13);
      box-shadow: 0 24px 50px rgba(0, 0, 0, 0.9);
    }

    .mobileHint {
      margin: 8px auto 0;
      font-size: 0.8rem;
      color: var(--text-muted);
      text-align: center;
    }

    /* Game Over */

    #gameOver .card {
      background: radial-gradient(circle at top, #4a1c2f 0, #15121f 55%);
      border-radius: 18px;
      padding: 20px 18px 16px;
      max-width: 420px;
      width: 100%;
      border: 1px solid rgba(255, 255, 255, 0.13);
      box-shadow: 0 20px 45px rgba(0, 0, 0, 0.85);
      text-align: center;
    }

    #gameOver h2 {
      font-size: 1.4rem;
      color: var(--danger);
      text-transform: uppercase;
      letter-spacing: 0.15em;
      margin-bottom: 2px;
      text-shadow: 0 0 10px rgba(255, 82, 82, 0.7);
    }

    .gameover-sub {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-bottom: 14px;
    }

    .score-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.9rem;
      margin: 4px 0;
      color: var(--text-muted);
    }

    .score-row strong {
      color: var(--accent);
    }

    .gameover-actions {
      margin-top: 14px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .gameover-label {
      font-size: 0.78rem;
      color: var(--text-muted);
      margin-top: 8px;
    }

    /* Responsive */

    @media (max-width: 700px) {
      .screen {
        padding: 16px 10px 12px;
        min-height: 88vh;
      }

      .screen-header h1 {
        font-size: 1.35rem;
      }

      .menu-card {
        padding: 16px 14px;
      }

      .hud {
        flex-direction: column;
        align-items: flex-start;
        border-radius: 14px;
      }

      .hud-right {
        align-self: flex-end;
      }

      .mobileHint {
        font-size: 0.75rem;
      }
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <!-- MAIN MENU -->
    <section id="mainMenu" class="screen active">
      <div class="screen-header">
        <h1>Parallax Runner+</h1>
        <p>Cartoon side-scroller with triple jump, power-ups and evolving chaos.</p>
      </div>

      <div class="menu-card">
        <div class="menu-section">
          <div class="menu-section-title">Difficulty</div>
          <div class="difficulty-toggle" id="difficultyToggle">
            <button class="difficulty-btn" data-difficulty="easy">Easy</button>
            <button class="difficulty-btn active" data-difficulty="normal">
              Normal
            </button>
            <button class="difficulty-btn" data-difficulty="hard">Hard</button>
          </div>
          <p class="helper-text">
            Easy = slower world and fewer waves. Hard = faster pace and dense obstacle storms.
            All modes spawn more and more obstacles over time.
          </p>
        </div>

        <div class="menu-section">
          <div class="menu-section-title">Play</div>
          <div class="menu-main-buttons">
            <button id="btnStart" class="btn">Start Game</button>
            <button id="btnInstructions" class="btn btn-ghost">
              Instructions
            </button>
          </div>
        </div>

        <div class="menu-section">
          <div class="menu-section-title">Controls</div>
          <p class="helper-text">
            Desktop: press <span class="kbd">Space</span> to jump
            (up to 3 jumps in mid-air by default).<br />
            Mobile: tap anywhere on the game area.
          </p>
        </div>
      </div>
    </section>

    <!-- INSTRUCTIONS -->
    <section id="instructions" class="screen">
      <div class="screen-header">
        <h1>How to Play</h1>
        <p>Survive, stomp obstacles, grab power-ups and ride through parallax worlds.</p>
      </div>

      <div class="content">
        <div class="instructions-grid">
          <div>
            <h3>Movement</h3>
            <ul>
              <li>Your runner moves automatically toward the right side of the screen.</li>
              <li>Press <span class="kbd">Space</span> (or tap on mobile) to jump.</li>
              <li>You can chain up to <strong>3 jumps</strong> in the air by default.</li>
              <li>Stomping an obstacle from above restores all jumps.</li>
              <li>Power-ups can temporarily increase or modify your abilities.</li>
            </ul>
          </div>

          <div>
            <h3>Obstacles &amp; Stomp</h3>
            <ul>
              <li>Obstacles come in different shapes and heights: ground, floating and ceiling traps.</li>
              <li>Some obstacles also move horizontally as they slide across the screen.</li>
              <li>Touching an obstacle from the side or below = instant loss (unless shielded).</li>
              <li>If you land on an obstacle from above you <strong>stomp</strong> it, destroy it, and get bonus points and jumps back.</li>
              <li>Obstacle intensity grows gradually as time passes.</li>
            </ul>
          </div>

          <div>
            <h3>Power-ups</h3>
            <ul>
              <li><strong>Shield</strong>: absorbs one hit and turns it into a safe smash.</li>
              <li><strong>Jump Boost</strong>: temporarily increases your available jumps.</li>
              <li><strong>Score Burst</strong>: grants extra points instantly.</li>
              <li><strong>Slow Time</strong>: temporarily slows the world speed.</li>
              <li>Catch power-ups by running through them.</li>
            </ul>
          </div>

          <div>
            <h3>Score</h3>
            <ul>
              <li><strong>+1</strong> point every second you stay alive (live counter).</li>
              <li><strong>+1</strong> point for each obstacle destroyed (stomp or shield-hit).</li>
              <li>Some power-ups add bonus points.</li>
              <li>Your total score is shown live at the top and updates every frame.</li>
            </ul>
          </div>

          <div>
            <h3>Levels &amp; Parallax</h3>
            <ul>
              <li>Survive to automatically advance through multiple parallax worlds (city, desert, mountains).</li>
              <li>Each level has its own layered background with sun, clouds, hills and buildings.</li>
              <li>Additional floating platforms let you route above or below, with gaps to drop or climb.</li>
            </ul>
          </div>

          <div>
            <h3>Difficulty</h3>
            <ul>
              <li>Choose <strong>Easy / Normal / Hard</strong> from the main menu.</li>
              <li>Difficulty controls world speed and base obstacle frequency.</li>
              <li>All difficulties gradually ramp up the number of obstacles.</li>
            </ul>
          </div>
        </div>

        <div class="instructions-footer">
          <button id="btnBackToMenu" class="btn btn-ghost">
            Back to Menu
          </button>
          <button id="btnPlayFromInstructions" class="btn">Play Now</button>
        </div>
      </div>
    </section>

    <!-- GAME -->
    <section id="gameContainer" class="screen">
      <div class="hud">
        <div class="hud-left">
          <div class="hud-pill score">
            SCORE:
            <strong id="scoreDisplay">0</strong>
          </div>
          <div class="hud-pill">
            LEVEL:
            <strong id="levelDisplay">1 – City</strong>
          </div>
          <div class="hud-pill">
            MODE:
            <strong id="difficultyDisplay">Normal</strong>
          </div>
          <div class="hud-pill">
            SHIELD:
            <strong id="shieldDisplay">Off</strong>
          </div>
          <div class="hud-pill">
            JUMP BOOST:
            <strong id="jumpBoostDisplay">-</strong>
          </div>
          <div class="hud-pill">
            BONUS:
            <strong id="bonusDisplay">0</strong>
          </div>
          <div class="hud-pill">
            SLOW:
            <strong id="slowDisplay">Off</strong>
          </div>
        </div>
        <div class="hud-right">
          <span class="hud-dot"></span>
          Running
        </div>
      </div>

      <canvas id="gameCanvas" width="1280" height="640"></canvas>
      <p class="mobileHint">
        Desktop: press <span class="kbd">Space</span> to jump (up to 3 times by default).<br />
        Stomping an obstacle from above restores all jumps. Mobile: tap anywhere on the game area.
      </p>
    </section>

    <!-- GAME OVER -->
    <section id="gameOver" class="screen">
      <div class="card">
        <h2>Game Over</h2>
        <p class="gameover-sub">
          The world caught you. Press "Restart", or press Space to try again.
        </p>

        <div class="score-row">
          <span>Final Score</span>
          <strong id="finalScoreDisplay">0</strong>
        </div>
        <div class="score-row">
          <span>Best Score (this session)</span>
          <strong id="bestScoreDisplay">0</strong>
        </div>
        <div class="score-row">
          <span>Obstacles Destroyed</span>
          <strong id="destroyedDisplay">0</strong>
        </div>
        <div class="score-row">
          <span>Time Survived</span>
          <strong id="timeDisplay">0 s</strong>
        </div>

        <div class="gameover-actions">
          <button id="btnRestart" class="btn">Restart</button>
          <button id="btnReturnToMenu" class="btn btn-ghost">
            Return to Main Menu
          </button>
        </div>

        <p class="gameover-label">
          Tip: Use upper platforms and stomps to refill jumps and farm extra points.
        </p>
      </div>
    </section>
  </div>

  <script>
    // NOTE FOR AUDIO:
    // Coloca un archivo MP3 en tu repo en la ruta:
    // /assets/audio/game-start.mp3
    // (por ejemplo en: <raiz-del-repo>/assets/audio/game-start.mp3)
    // El juego lo reproducirá al iniciar cada partida.

    // ---------- Basic DOM helpers ----------
    const screens = {
      mainMenu: document.getElementById("mainMenu"),
      instructions: document.getElementById("instructions"),
      gameContainer: document.getElementById("gameContainer"),
      gameOver: document.getElementById("gameOver"),
    };
    let currentScreen = "mainMenu";

    function showScreen(key) {
      Object.values(screens).forEach((el) =>
        el.classList.remove("active")
      );
      screens[key].classList.add("active");
      currentScreen = key;
    }

    // ---------- Difficulty ----------
    const difficultyToggle = document.getElementById("difficultyToggle");
    const difficultyButtons =
      difficultyToggle.querySelectorAll(".difficulty-btn");
    const difficultyDisplay = document.getElementById("difficultyDisplay");
    const shieldDisplay = document.getElementById("shieldDisplay");
    const jumpBoostDisplay = document.getElementById("jumpBoostDisplay");
    const bonusDisplay = document.getElementById("bonusDisplay");
    const slowDisplay = document.getElementById("slowDisplay");

    let difficulty = "normal";

    const difficultySettings = {
      easy: {
        speed: 260,
        minSpawn: 0.55,
        maxSpawn: 0.8,
      },
      normal: {
        speed: 320,
        minSpawn: 0.38,
        maxSpawn: 0.6,
      },
      hard: {
        speed: 380,
        minSpawn: 0.25,
        maxSpawn: 0.45,
      },
    };

    difficultyButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        difficultyButtons.forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        difficulty = btn.dataset.difficulty;
        difficultyDisplay.textContent =
          difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
      });
    });

    // ---------- Canvas + Game State ----------
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const GAME_WIDTH = canvas.width;
    const GAME_HEIGHT = canvas.height;
    const GROUND_HEIGHT = 140;
    const GROUND_TOP = GAME_HEIGHT - GROUND_HEIGHT;

    const GRAVITY = 2000;
    const JUMP_FORCE = 750;
    const LEVEL_DURATION = 25;
    const BASE_MAX_JUMPS = 3;

    const PLATFORM_LENGTH = 260;
    const PLATFORM_GAP = 180;

    const scoreDisplay = document.getElementById("scoreDisplay");
    const levelDisplay = document.getElementById("levelDisplay");

    const finalScoreDisplay = document.getElementById("finalScoreDisplay");
    const bestScoreDisplay = document.getElementById("bestScoreDisplay");
    const destroyedDisplay = document.getElementById("destroyedDisplay");
    const timeDisplay = document.getElementById("timeDisplay");

    let lastTime = 0;
    let isRunning = false;

    let player;
    let obstacles = [];
    let powerups = [];
    let platforms = [];

    let survivalTime = 0;
    let obstaclesDestroyed = 0;
    let bonusScore = 0;
    let bestScore = 0;

    let obstacleTimer = 0;
    let nextObstacleSpawn = 1;

    let powerTimer = 0;
    let nextPowerSpawn = 8;

    let currentLevelIndex = 0;

    let maxJumps = BASE_MAX_JUMPS;
    let haveShield = false;
    let jumpBoostTime = 0;
    let slowTime = 0;
    let speedFactor = 1;

    // Running animation (very fast)
    let runAnimationTime = 0;

    const levelThemes = [
      {
        name: "City",
        sky: "#8ed6ff",
        far: "#283593",
        mid: "#3949ab",
        ground: "#43a047",
      },
      {
        name: "Desert",
        sky: "#ffe082",
        far: "#ffb74d",
        mid: "#fb8c00",
        ground: "#f9a825",
      },
      {
        name: "Mountains",
        sky: "#b3e5fc",
        far: "#5c6bc0",
        mid: "#455a64",
        ground: "#4caf50",
      },
    ];

    let parallaxLayers = [];

    function applyLevelTheme() {
      const theme =
        levelThemes[currentLevelIndex % levelThemes.length];

      parallaxLayers = [
        {
          color: theme.far,
          y: GAME_HEIGHT - 320,
          h: 220,
          speedFactor: 0.25,
          offset: 0,
        },
        {
          color: theme.mid,
          y: GAME_HEIGHT - 250,
          h: 200,
          speedFactor: 0.5,
          offset: 0,
        },
        {
          color: theme.ground,
          y: GROUND_TOP,
          h: GROUND_HEIGHT + 30,
          speedFactor: 1.0,
          offset: 0,
        },
      ];

      levelDisplay.textContent = `${currentLevelIndex + 1} – ${
        theme.name
      }`;
    }

    function initPlatforms() {
      platforms = [];
      const bands = [
        { y: GROUND_TOP - 110 },
        { y: GROUND_TOP - 220 },
      ];
      bands.forEach((band, index) => {
        const baseOffset = index === 0 ? 80 : 260;
        for (let i = 0; i < 3; i++) {
          platforms.push({
            x: baseOffset + i * (PLATFORM_LENGTH + PLATFORM_GAP),
            w: PLATFORM_LENGTH,
            y: band.y,
            h: 18,
            band: index,
          });
        }
      });
    }

    function randRange(min, max) {
      return min + Math.random() * (max - min);
    }

    function computeObstacleSpawnWindow() {
      const settings = difficultySettings[difficulty];
      const progress = Math.min(1, survivalTime / 60);
      const factor = 1 - 0.65 * progress; // 1 -> 0.35
      return {
        min: settings.minSpawn * factor,
        max: settings.maxSpawn * factor,
      };
    }

    function resetGameState() {
      const theme = levelThemes[0];
      parallaxLayers = [
        {
          color: theme.far,
          y: GAME_HEIGHT - 320,
          h: 220,
          speedFactor: 0.25,
          offset: 0,
        },
        {
          color: theme.mid,
          y: GAME_HEIGHT - 250,
          h: 200,
          speedFactor: 0.5,
          offset: 0,
        },
        {
          color: theme.ground,
          y: GROUND_TOP,
          h: GROUND_HEIGHT + 30,
          speedFactor: 1.0,
          offset: 0,
        },
      ];

      // Smaller, shorter character
      player = {
        w: 32,
        h: 60,
        x: GAME_WIDTH * 0.18,
        y: GROUND_TOP - 60,
        vy: 0,
        jumpCount: 0,
      };

      initPlatforms();

      obstacles = [];
      powerups = [];
      survivalTime = 0;
      obstaclesDestroyed = 0;
      bonusScore = 0;
      obstacleTimer = 0;
      powerTimer = 0;
      const spawnWindow = computeObstacleSpawnWindow();
      nextObstacleSpawn = randRange(spawnWindow.min, spawnWindow.max);
      nextPowerSpawn = randRange(6, 11);
      currentLevelIndex = 0;

      maxJumps = BASE_MAX_JUMPS;
      haveShield = false;
      jumpBoostTime = 0;
      slowTime = 0;
      speedFactor = 1;
      applyLevelTheme();
      updateScoreDisplay();
      updatePowerHud();
      runAnimationTime = 0;
    }

    function spawnObstacle() {
      const typeRoll = Math.random();

      let w, h;
      if (typeRoll < 0.4) {
        w = 36;
        h = 40;
      } else if (typeRoll < 0.75) {
        w = 44;
        h = 65;
      } else {
        w = 60;
        h = 34;
      }

      let y;
      const verticalRoll = Math.random();
      let verticalType;
      if (verticalRoll < 0.45) {
        y = GROUND_TOP - h;
        verticalType = "ground";
      } else if (verticalRoll < 0.8) {
        const minY = GROUND_TOP - h - 220;
        const maxY = GROUND_TOP - h - 100;
        y = randRange(Math.max(60, minY), Math.max(80, maxY));
        verticalType = "floating";
      } else {
        y = randRange(40, 150);
        verticalType = "ceiling";
      }

      let shape = "box";
      const shapeRoll = Math.random();
      if (shapeRoll < 0.5) shape = "box";
      else if (shapeRoll < 0.8) shape = "circle";
      else shape = "spike";

      // Some obstacles move horizontally (zig-zag)
      let moveType = "static";
      let amplitude = 0;
      let moveSpeed = 0;
      let phase = 0;

      const moveRoll = Math.random();
      if (moveRoll < 0.35) {
        moveType = "hmove";
        amplitude = randRange(15, 40);
        moveSpeed = randRange(3.5, 7);
        phase = Math.random() * Math.PI * 2;
      }

      const baseX = GAME_WIDTH + w;

      obstacles.push({
        baseX,
        x: baseX,
        y,
        w,
        h,
        shape,
        verticalType,
        moveType,
        amplitude,
        moveSpeed,
        phase,
        offsetX: 0,
      });

      const spawnWindow = computeObstacleSpawnWindow();
      nextObstacleSpawn = randRange(
        spawnWindow.min,
        spawnWindow.max
      );
    }

    function spawnPowerup() {
      const kinds = ["shield", "jump", "score", "slow"];
      const kind = kinds[Math.floor(Math.random() * kinds.length)];

      const size = 32;
      const heightRoll = Math.random();
      let y;
      if (heightRoll < 0.33) {
        y = GROUND_TOP - size - 70;
      } else if (heightRoll < 0.66) {
        y = GROUND_TOP - size - 160;
      } else {
        y = randRange(90, GROUND_TOP - size - 160);
      }

      powerups.push({
        x: GAME_WIDTH + 80,
        y,
        w: size,
        h: size,
        kind,
      });

      const progress = Math.min(1, survivalTime / 80);
      const factor = 1 - 0.4 * progress;
      nextPowerSpawn = randRange(7 * factor, 13 * factor);
    }

    function rectsOverlap(a, b) {
      return !(
        a.x + a.w < b.x ||
        a.x > b.x + b.w ||
        a.y + a.h < b.y ||
        a.y > b.y + b.h
      );
    }

    function getDisplayedScore() {
      // Live score: 1 pt/s + 1 per obstacle + bonus from powers
      return Math.floor(survivalTime) + obstaclesDestroyed + bonusScore;
    }

    function updateScoreDisplay() {
      scoreDisplay.textContent = getDisplayedScore();
    }

    function updatePowerHud() {
      shieldDisplay.textContent = haveShield ? "On" : "Off";
      if (jumpBoostTime > 0) {
        jumpBoostDisplay.textContent =
          Math.ceil(jumpBoostTime) + "s";
      } else {
        jumpBoostDisplay.textContent = "-";
      }
      bonusDisplay.textContent = bonusScore;
      slowDisplay.textContent = slowTime > 0 ? "On" : "Off";
    }

    // ---------- Audio ----------
    let audioCtx = null;
    const startSound = new Audio("assets/audio/game-start.mp3");

    function ensureAudioContext() {
      if (!audioCtx) {
        const AudioContext =
          window.AudioContext || window.webkitAudioContext;
        if (!AudioContext) return;
        audioCtx = new AudioContext();
      }
      if (audioCtx && audioCtx.state === "suspended") {
        audioCtx.resume().catch(() => {});
      }
    }

    function playStartSound() {
      try {
        ensureAudioContext();
        startSound.currentTime = 0;
        startSound.play().catch(() => {});
      } catch (_) {
        // ignore audio errors
      }
    }

    function playBeep(type) {
      try {
        ensureAudioContext();
        if (!audioCtx) return;

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        let freq = 440;
        let dur = 0.08;

        switch (type) {
          case "jump":
            freq = 640;
            dur = 0.07;
            break;
          case "stomp":
            freq = 280;
            dur = 0.1;
            break;
          case "hit":
            freq = 140;
            dur = 0.18;
            break;
          case "power":
            freq = 820;
            dur = 0.15;
            break;
        }

        osc.type = "sine";
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.22, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(
          0.001,
          audioCtx.currentTime + dur
        );
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + dur);
      } catch (_) {
        // ignore
      }
    }

    function applyPowerup(kind) {
      if (kind === "shield") {
        haveShield = true;
      } else if (kind === "jump") {
        jumpBoostTime = 10;
      } else if (kind === "score") {
        bonusScore += 10;
      } else if (kind === "slow") {
        slowTime = 6;
        speedFactor = 0.6;
      }
      updatePowerHud();
    }

    function updatePlatforms(dt, gameSpeed) {
      // Move and wrap platforms band by band
      for (let bandIndex = 0; bandIndex < 2; bandIndex++) {
        let maxXInBand = -Infinity;
        platforms.forEach((p) => {
          if (p.band === bandIndex && p.x > maxXInBand) {
            maxXInBand = p.x;
          }
        });

        platforms.forEach((p) => {
          if (p.band !== bandIndex) return;
          p.x -= gameSpeed * dt;
          if (p.x + p.w < -120) {
            p.x = maxXInBand + PLATFORM_LENGTH + PLATFORM_GAP;
            maxXInBand = p.x;
          }
        });
      }
    }

    function updateGame(dt) {
      if (!isRunning) return;

      // Timers and powers
      if (jumpBoostTime > 0) {
        jumpBoostTime -= dt;
        if (jumpBoostTime < 0) jumpBoostTime = 0;
      }
      if (slowTime > 0) {
        slowTime -= dt;
        if (slowTime <= 0) {
          slowTime = 0;
          speedFactor = 1;
        }
      }

      maxJumps = jumpBoostTime > 0 ? 5 : BASE_MAX_JUMPS;
      updatePowerHud();

      const settings = difficultySettings[difficulty];
      const gameSpeed = settings.speed * speedFactor;

      // Level progression & live time score
      survivalTime += dt;
      const targetLevel =
        Math.floor(survivalTime / LEVEL_DURATION);
      if (targetLevel !== currentLevelIndex) {
        currentLevelIndex = targetLevel;
        applyLevelTheme();
      }

      // Player physics
      const prevBottom = player.y + player.h;

      player.vy += GRAVITY * dt;
      let newY = player.y + player.vy * dt;
      let newBottom = newY + player.h;
      let onPlatform = false;

      // Platforms collision (from above only)
      for (let i = 0; i < platforms.length; i++) {
        const pf = platforms[i];
        const platformTop = pf.y;
        const overlapsHoriz =
          player.x + player.w > pf.x &&
          player.x < pf.x + pf.w;

        if (
          overlapsHoriz &&
          prevBottom <= platformTop &&
          newBottom >= platformTop
        ) {
          newY = platformTop - player.h;
          newBottom = newY + player.h;
          player.vy = 0;
          player.jumpCount = 0; // landing on platform restores jumps
          onPlatform = true;
          break;
        }
      }

      // Ground collision
      if (!onPlatform && newBottom >= GROUND_TOP) {
        newY = GROUND_TOP - player.h;
        newBottom = newY + player.h;
        player.vy = 0;
        player.jumpCount = 0;
      }

      player.y = newY;

      // Platforms movement
      updatePlatforms(dt, gameSpeed);

      // Obstacles movement
      obstacleTimer += dt;
      if (obstacleTimer >= nextObstacleSpawn) {
        spawnObstacle();
        obstacleTimer = 0;
      }

      const playerRect = {
        x: player.x,
        y: player.y,
        w: player.w,
        h: player.h,
      };

      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        // base scroll
        o.baseX -= gameSpeed * dt;

        // horizontal movement (local)
        if (o.moveType === "hmove") {
          o.phase += o.moveSpeed * dt;
          o.offsetX = Math.sin(o.phase) * o.amplitude;
        } else {
          o.offsetX = 0;
        }

        o.x = o.baseX + o.offsetX;

        if (o.baseX + o.w < -80) {
          obstacles.splice(i, 1);
          continue;
        }
      }

      // Collision and stomp / shield
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];

        if (rectsOverlap(playerRect, o)) {
          const wasAbove = prevBottom <= o.y + 8;
          if (wasAbove && player.vy > 0) {
            // Stomp: destroy, bounce and restore jumps
            obstacles.splice(i, 1);
            obstaclesDestroyed++;
            player.vy = -JUMP_FORCE * 0.7;
            player.jumpCount = 0; // restore all jumps after stomp
            playBeep("stomp");
          } else if (haveShield) {
            haveShield = false;
            updatePowerHud();
            obstacles.splice(i, 1);
            obstaclesDestroyed++;
            playBeep("stomp");
          } else {
            playBeep("hit");
            handleGameOver();
            return;
          }
        }
      }

      // Power-ups
      powerTimer += dt;
      if (powerTimer >= nextPowerSpawn) {
        spawnPowerup();
        powerTimer = 0;
      }

      for (let i = powerups.length - 1; i >= 0; i--) {
        const p = powerups[i];
        p.x -= gameSpeed * dt * 0.8;

        if (p.x + p.w < -80) {
          powerups.splice(i, 1);
          continue;
        }

        if (rectsOverlap(playerRect, p)) {
          applyPowerup(p.kind);
          playBeep("power");
          powerups.splice(i, 1);
        }
      }

      updateScoreDisplay();

      // Parallax background movement
      parallaxLayers.forEach((layer) => {
        layer.offset -= gameSpeed * layer.speedFactor * dt;
        if (layer.offset <= -GAME_WIDTH) {
          layer.offset += GAME_WIDTH;
        }
      });

      // Running animation
      runAnimationTime += dt;
    }

    function drawSkyDetails(theme) {
      // Sun
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = "#ffe082";
      const sunX = GAME_WIDTH * 0.12;
      const sunY = 80;
      const sunR = 50;
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunR, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Clouds
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      const cloudBaseY = 70;
      for (let i = 0; i < 4; i++) {
        const offset = (survivalTime * 40 + i * 260) % (GAME_WIDTH + 200);
        const x = offset - 100;
        const y = cloudBaseY + (i % 2) * 25;
        ctx.beginPath();
        ctx.ellipse(x, y, 55, 24, 0, 0, Math.PI * 2);
        ctx.ellipse(x + 30, y - 10, 40, 20, 0, 0, Math.PI * 2);
        ctx.ellipse(x - 25, y - 8, 32, 18, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();

      // Distant mountains / dunes / hills / buildings
      ctx.save();
      if (theme.name === "Mountains") {
        ctx.fillStyle = theme.far;
        const baseY = GAME_HEIGHT - 260;
        for (let i = 0; i < 5; i++) {
          const w = 220;
          const x = i * 220 - (survivalTime * 30 % 220);
          ctx.beginPath();
          ctx.moveTo(x, baseY + 120);
          ctx.lineTo(x + w / 2, baseY);
          ctx.lineTo(x + w, baseY + 120);
          ctx.closePath();
          ctx.fill();
        }
      } else if (theme.name === "Desert") {
        ctx.fillStyle = theme.far;
        const baseY = GAME_HEIGHT - 240;
        for (let i = 0; i < 4; i++) {
          const w = 260;
          const x = i * 260 - (survivalTime * 25 % 260);
          ctx.beginPath();
          ctx.moveTo(x, baseY + 90);
          ctx.quadraticCurveTo(
            x + w / 2,
            baseY - 10,
            x + w,
            baseY + 90
          );
          ctx.lineTo(x + w, GAME_HEIGHT);
          ctx.lineTo(x, GAME_HEIGHT);
          ctx.closePath();
          ctx.fill();
        }
      } else {
        // City skyline
        const baseY = GAME_HEIGHT - 260;
        for (let i = 0; i < 10; i++) {
          const w = 70;
          const h = 80 + (i % 3) * 30;
          const x =
            i * 120 - (survivalTime * 40 % 120);
          ctx.fillStyle =
            i % 2 === 0 ? theme.far : theme.mid;
          ctx.fillRect(x, baseY + 140 - h, w, h);

          // windows
          ctx.fillStyle = "rgba(255, 249, 196, 0.8)";
          for (let r = 0; r < 4; r++) {
            for (let c = 0; c < 2; c++) {
              if ((r + c + i) % 2 === 0) continue;
              const wx = x + 8 + c * 26;
              const wy = baseY + 132 - h + r * 18;
              ctx.fillRect(wx, wy, 10, 8);
            }
          }
        }
      }
      ctx.restore();
    }

    function drawGame() {
      const theme =
        levelThemes[currentLevelIndex % levelThemes.length];

      // Sky
      ctx.fillStyle = theme.sky;
      ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

      // Decorative elements: sun, clouds, mountains/buildings
      drawSkyDetails(theme);

      // Parallax layers (hills/ground bands)
      parallaxLayers.forEach((layer) => {
        ctx.fillStyle = layer.color;
        const offset = layer.offset;
        ctx.fillRect(offset, layer.y, GAME_WIDTH, layer.h);
        ctx.fillRect(
          offset + GAME_WIDTH,
          layer.y,
          GAME_WIDTH,
          layer.h
        );
      });

      // Platforms (extra floors with gaps)
      ctx.save();
      ctx.fillStyle = "rgba(236, 239, 241, 0.95)";
      ctx.strokeStyle = "rgba(120, 144, 156, 0.9)";
      ctx.lineWidth = 2;
      platforms.forEach((pf) => {
        ctx.fillRect(pf.x, pf.y, pf.w, pf.h);
        ctx.strokeRect(pf.x, pf.y, pf.w, pf.h);
      });
      ctx.restore();

      // Player (smaller runner)
      ctx.save();
      ctx.translate(player.x, player.y);

      // Body
      ctx.fillStyle = "#ffeb3b";
      const torsoW = 18;
      const torsoH = 26;
      const torsoX = (player.w - torsoW) / 2;
      const torsoY = 18;
      ctx.fillRect(torsoX, torsoY, torsoW, torsoH);

      // Head
      ctx.fillStyle = "#ffe082";
      const headSize = 18;
      const headX = (player.w - headSize) / 2;
      const headY = 2;
      if (ctx.roundRect) {
        ctx.beginPath();
        ctx.roundRect(headX, headY, headSize, headSize, 5);
        ctx.fill();
      } else {
        ctx.fillRect(headX, headY, headSize, headSize);
      }

      // Headband
      ctx.fillStyle = "#ff5252";
      ctx.fillRect(headX, headY + 4, headSize, 5);

      // Face
      ctx.fillStyle = "#212121";
      ctx.fillRect(headX + 4, headY + 8, 2, 2);
      ctx.fillRect(headX + 11, headY + 8, 2, 2);
      ctx.beginPath();
      ctx.strokeStyle = "#212121";
      ctx.lineWidth = 1.3;
      ctx.arc(
        headX + headSize / 2,
        headY + 13,
        4,
        0.15 * Math.PI,
        0.85 * Math.PI
      );
      ctx.stroke();

      // Arms (very fast movement)
      const armBaseY = torsoY + 8;
      const armLength = 14;
      const armSwing = Math.sin(runAnimationTime * 90) * 5;

      ctx.strokeStyle = "#ffeb3b";
      ctx.lineWidth = 3;
      ctx.lineCap = "round";

      // Front arm
      ctx.beginPath();
      ctx.moveTo(torsoX + torsoW, armBaseY);
      ctx.lineTo(
        torsoX + torsoW + armLength * 0.9,
        armBaseY + armSwing
      );
      ctx.stroke();

      // Back arm
      ctx.beginPath();
      ctx.moveTo(torsoX, armBaseY + 3);
      ctx.lineTo(
        torsoX - armLength * 0.6,
        armBaseY - armSwing * 0.8
      );
      ctx.stroke();

      // Legs (very fast movement)
      const legBaseY = torsoY + torsoH;
      const legBaseX = player.w / 2;
      const legLength = 22;
      const legSwing = Math.sin(runAnimationTime * 90 + Math.PI) * 7;

      ctx.strokeStyle = "#ffca28";
      ctx.lineWidth = 4;

      // Right leg
      ctx.beginPath();
      ctx.moveTo(legBaseX + 3, legBaseY);
      ctx.lineTo(
        legBaseX + 3 + legSwing,
        legBaseY + legLength
      );
      ctx.stroke();

      // Left leg
      ctx.beginPath();
      ctx.moveTo(legBaseX - 3, legBaseY);
      ctx.lineTo(
        legBaseX - 3 - legSwing,
        legBaseY + legLength
      );
      ctx.stroke();

      ctx.restore();

      // Obstacles
      obstacles.forEach((o) => {
        ctx.save();
        ctx.translate(o.x, o.y);

        let color = "#ff5252";
        if (o.verticalType === "floating") color = "#ff8a65";
        else if (o.verticalType === "ceiling") color = "#ff7043";

        ctx.fillStyle = color;
        ctx.strokeStyle = "rgba(0,0,0,0.6)";
        ctx.lineWidth = 2;

        if (o.shape === "box") {
          ctx.fillRect(0, 0, o.w, o.h);
          ctx.strokeRect(0, 0, o.w, o.h);
        } else if (o.shape === "circle") {
          const r = Math.min(o.w, o.h) / 2;
          ctx.beginPath();
          ctx.arc(o.w / 2, o.h / 2, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        } else {
          ctx.beginPath();
          ctx.moveTo(0, o.h);
          ctx.lineTo(o.w / 2, 0);
          ctx.lineTo(o.w, o.h);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        }

        ctx.restore();
      });

      // Power-ups
      powerups.forEach((p) => {
        ctx.save();
        ctx.translate(p.x, p.y);

        if (p.kind === "shield") {
          ctx.fillStyle = "#40c4ff";
          ctx.strokeStyle = "rgba(0,0,0,0.5)";
          ctx.lineWidth = 2;
          const r = p.w / 2;
          ctx.beginPath();
          ctx.arc(r, r, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          ctx.fillStyle = "#ffffff";
          ctx.font = "bold 14px system-ui";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("S", r, r);
        } else if (p.kind === "jump") {
          ctx.fillStyle = "#66bb6a";
          ctx.strokeStyle = "rgba(0,0,0,0.5)";
          ctx.lineWidth = 2;
          const r = 6;
          if (ctx.roundRect) {
            ctx.beginPath();
            ctx.roundRect(0, 0, p.w, p.h, r);
            ctx.fill();
            ctx.stroke();
          } else {
            ctx.fillRect(0, 0, p.w, p.h);
            ctx.strokeRect(0, 0, p.w, p.h);
          }

          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(p.w / 2, p.h - 6);
          ctx.lineTo(p.w / 2, 8);
          ctx.moveTo(p.w / 2, 8);
          ctx.lineTo(p.w / 2 - 5, 13);
          ctx.moveTo(p.w / 2, 8);
          ctx.lineTo(p.w / 2 + 5, 13);
          ctx.stroke();
        } else if (p.kind === "score") {
          // Score Burst: star
          ctx.fillStyle = "#ffd54f";
          ctx.strokeStyle = "rgba(0,0,0,0.5)";
          ctx.lineWidth = 2;
          const cx = p.w / 2;
          const cy = p.h / 2;
          const outer = 14;
          const inner = 6;
          ctx.beginPath();
          for (let i = 0; i < 10; i++) {
            const angle = (i * Math.PI) / 5;
            const r = i % 2 === 0 ? outer : inner;
            const x = cx + Math.cos(angle) * r;
            const y = cy + Math.sin(angle) * r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        } else if (p.kind === "slow") {
          // Slow Time: clock
          ctx.fillStyle = "#b39ddb";
          ctx.strokeStyle = "rgba(0,0,0,0.5)";
          ctx.lineWidth = 2;
          const r = p.w / 2;
          ctx.beginPath();
          ctx.arc(r, r, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 2;
          // clock hands
          ctx.beginPath();
          ctx.moveTo(r, r);
          ctx.lineTo(r, r - 7);
          ctx.moveTo(r, r);
          ctx.lineTo(r + 6, r + 3);
          ctx.stroke();
        }

        ctx.restore();
      });

      // Ground highlight line
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, GROUND_TOP + 1.5);
      ctx.lineTo(GAME_WIDTH, GROUND_TOP + 1.5);
      ctx.stroke();

      // Jump "notepad"
      const jumpsLeft = Math.max(0, maxJumps - player.jumpCount);
      const noteX = player.x + player.w + 10;
      const noteY = player.y + 4;
      const noteW = 80;
      const noteH = 26;

      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(noteX, noteY, noteW, noteH);
      ctx.strokeStyle = "rgba(255,255,255,0.6)";
      ctx.lineWidth = 1.5;
      ctx.strokeRect(noteX, noteY, noteW, noteH);

      ctx.fillStyle = "#ffeb3b";
      ctx.font = "10px system-ui";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.fillText("Jumps", noteX + 6, noteY + 3);
      ctx.fillText("left: " + jumpsLeft, noteX + 6, noteY + 14);
    }

    function gameLoop(timestamp) {
      if (!isRunning) return;

      if (!lastTime) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      updateGame(dt);
      drawGame();

      if (isRunning) {
        requestAnimationFrame(gameLoop);
      }
    }

    function startGame() {
      resetGameState();
      showScreen("gameContainer");
      isRunning = true;
      lastTime = 0;
      playStartSound();
      requestAnimationFrame(gameLoop);
    }

    function handleGameOver() {
      isRunning = false;
      const finalScore = getDisplayedScore();
      bestScore = Math.max(bestScore, finalScore);

      finalScoreDisplay.textContent = finalScore;
      bestScoreDisplay.textContent = bestScore;
      destroyedDisplay.textContent = obstaclesDestroyed;
      timeDisplay.textContent = `${Math.floor(survivalTime)} s`;

      showScreen("gameOver");
    }

    function restartGame() {
      startGame();
    }

    // ---------- Input ----------
    function tryJump() {
      if (!isRunning) return;
      if (player.jumpCount < maxJumps) {
        player.vy = -JUMP_FORCE;
        player.jumpCount++;
        playBeep("jump");
      }
    }

    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        if (isRunning && currentScreen === "gameContainer") {
          tryJump();
        } else if (!isRunning && currentScreen === "gameOver") {
          // Restart with Space on Game Over screen
          restartGame();
        }
      }
    });

    // Mobile tap for jump
    function addTapListener(target) {
      target.addEventListener(
        "touchstart",
        (e) => {
          e.preventDefault();
          tryJump();
        },
        { passive: false }
      );
    }
    addTapListener(canvas);
    addTapListener(document.body);

    // ---------- Buttons ----------
    document.getElementById("btnStart").addEventListener("click", () => {
      startGame();
    });

    document
      .getElementById("btnInstructions")
      .addEventListener("click", () => {
        showScreen("instructions");
      });

    document
      .getElementById("btnBackToMenu")
      .addEventListener("click", () => {
        showScreen("mainMenu");
      });

    document
      .getElementById("btnPlayFromInstructions")
      .addEventListener("click", () => {
        startGame();
      });

    document.getElementById("btnRestart").addEventListener("click", () => {
      restartGame();
    });

    document
      .getElementById("btnReturnToMenu")
      .addEventListener("click", () => {
        showScreen("mainMenu");
      });
  </script>
</body>
</html>
