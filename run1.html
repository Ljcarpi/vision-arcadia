<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>2D Runner – Triple Jump+</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --ui-bg: #0b1020;
      --card-bg: #151a30;
      --accent: #ffca28;
      --accent-soft: rgba(255, 202, 40, 0.2);
      --danger: #ff5252;
      --text-main: #f5f5f5;
      --text-muted: #b0bec5;
    }

    * {
      box-sizing: border-box;
      padding: 0;
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
    }

    body {
      background: radial-gradient(circle at top, #283593 0, #0b1020 55%);
      min-height: 100vh;
      color: var(--text-main);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .wrapper {
      width: 100%;
      max-width: 1100px;
      padding: 16px;
    }

    .screen {
      background: linear-gradient(145deg, #151a30 0, #111425 60%, #03040b 100%);
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
      padding: 24px 18px 20px;
      display: none;
      min-height: min(90vh, 650px);
      position: relative;
      overflow: hidden;
    }

    .screen.active {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .screen-header {
      text-align: center;
      margin-bottom: 24px;
    }

    .screen-header h1 {
      font-size: 2rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      margin-bottom: 0.25rem;
      color: var(--accent);
      text-shadow: 0 0 12px rgba(255, 202, 40, 0.5);
    }

    .screen-header p {
      font-size: 0.95rem;
      color: var(--text-muted);
    }

    .menu-card {
      background: radial-gradient(circle at top left, #243b6b 0, #151a30 48%);
      border-radius: 18px;
      padding: 18px;
      max-width: 420px;
      width: 100%;
      border: 1px solid rgba(255, 255, 255, 0.07);
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.5);
    }

    .menu-section + .menu-section {
      margin-top: 18px;
      padding-top: 18px;
      border-top: 1px dashed rgba(255, 255, 255, 0.12);
    }

    .menu-section-title {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-muted);
      margin-bottom: 10px;
    }

    .btn {
      border: none;
      border-radius: 999px;
      padding: 10px 18px;
      font-size: 1rem;
      cursor: pointer;
      color: #10131f;
      background: linear-gradient(135deg, #ffca28, #ffeb3b);
      box-shadow: 0 8px 18px rgba(255, 202, 40, 0.45);
      font-weight: 600;
      transition:
        transform 0.12s ease,
        box-shadow 0.12s ease,
        filter 0.12s ease,
        background 0.15s ease;
      width: 100%;
      text-align: center;
    }

    .btn:hover {
      transform: translateY(-1px);
      filter: brightness(1.05);
      box-shadow: 0 10px 24px rgba(255, 202, 40, 0.6);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow: 0 6px 16px rgba(255, 202, 40, 0.5);
    }

    .btn-ghost {
      background: transparent;
      color: var(--accent);
      border: 1px solid rgba(255, 202, 40, 0.6);
      box-shadow: none;
    }

    .btn-ghost:hover {
      background: rgba(255, 202, 40, 0.09);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.6);
    }

    .difficulty-toggle {
      display: flex;
      gap: 6px;
      background: rgba(5, 10, 25, 0.9);
      padding: 4px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.07);
    }

    .difficulty-btn {
      flex: 1;
      border-radius: 999px;
      border: none;
      padding: 6px 0;
      font-size: 0.8rem;
      cursor: pointer;
      background: transparent;
      color: var(--text-muted);
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      transition:
        background 0.15s ease,
        color 0.15s ease,
        box-shadow 0.15s ease;
    }

    .difficulty-btn.active {
      background: linear-gradient(135deg, #ffca28, #ffb300);
      color: #10131f;
      box-shadow: 0 4px 14px rgba(255, 202, 40, 0.5);
    }

    .menu-main-buttons {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 6px;
    }

    .helper-text {
      font-size: 0.78rem;
      color: var(--text-muted);
      margin-top: 8px;
    }

    /* Instructions */

    #instructions .content {
      max-width: 560px;
      width: 100%;
      background: radial-gradient(circle at top, #263a6b 0, #151a30 50%);
      border-radius: 18px;
      padding: 18px 16px 16px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.5);
    }

    .instructions-grid {
      display: grid;
      gap: 12px;
      font-size: 0.9rem;
    }

    .instructions-grid h3 {
      font-size: 0.95rem;
      margin-bottom: 4px;
      color: var(--accent);
    }

    ul {
      padding-left: 16px;
      color: var(--text-muted);
    }

    li + li {
      margin-top: 4px;
    }

    .kbd {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 5px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(0, 0, 0, 0.4);
      font-size: 0.8rem;
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo,
        Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .instructions-footer {
      display: flex;
      justify-content: flex-end;
      margin-top: 16px;
      gap: 8px;
      flex-wrap: wrap;
    }

    /* Game */

    #gameContainer {
      padding: 14px 12px 14px;
      align-items: stretch;
      justify-content: flex-start;
      gap: 10px;
    }

    .hud {
      width: 100%;
      max-width: 960px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin: 0 auto;
      padding: 6px 10px;
      border-radius: 999px;
      background: linear-gradient(
        120deg,
        rgba(3, 6, 18, 0.95),
        rgba(7, 12, 35, 0.98)
      );
      border: 1px solid rgba(255, 255, 255, 0.07);
    }

    .hud-left {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .hud-pill {
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.09em;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: rgba(0, 0, 0, 0.55);
      color: var(--text-muted);
    }

    .hud-pill strong {
      color: var(--accent);
      font-weight: 700;
    }

    .hud-pill.score {
      background: radial-gradient(circle at top, #ffca28 0, #f57f17 72%);
      color: #10131f;
      box-shadow: 0 0 20px rgba(255, 202, 40, 0.6);
    }

    .hud-pill.score strong {
      color: #10131f;
    }

    .hud-right {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.75rem;
      color: var(--text-muted);
      flex-wrap: wrap;
    }

    .hud-dot {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: #53e079;
      box-shadow: 0 0 8px rgba(83, 224, 121, 0.7);
    }

    #gameCanvas {
      margin: 8px auto 0;
      width: 100%;
      max-width: 960px;
      border-radius: 18px;
      display: block;
      background: #7ec8ff;
      border: 1px solid rgba(255, 255, 255, 0.13);
      box-shadow: 0 24px 50px rgba(0, 0, 0, 0.9);
    }

    .mobileHint {
      margin: 8px auto 0;
      font-size: 0.8rem;
      color: var(--text-muted);
      text-align: center;
    }

    /* Game Over */

    #gameOver .card {
      background: radial-gradient(circle at top, #4a1c2f 0, #15121f 55%);
      border-radius: 18px;
      padding: 20px 18px 16px;
      max-width: 420px;
      width: 100%;
      border: 1px solid rgba(255, 255, 255, 0.13);
      box-shadow: 0 20px 45px rgba(0, 0, 0, 0.85);
      text-align: center;
    }

    #gameOver h2 {
      font-size: 1.4rem;
      color: var(--danger);
      text-transform: uppercase;
      letter-spacing: 0.15em;
      margin-bottom: 2px;
      text-shadow: 0 0 10px rgba(255, 82, 82, 0.7);
    }

    .gameover-sub {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-bottom: 14px;
    }

    .score-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.9rem;
      margin: 4px 0;
      color: var(--text-muted);
    }

    .score-row strong {
      color: var(--accent);
    }

    .gameover-actions {
      margin-top: 14px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .gameover-label {
      font-size: 0.78rem;
      color: var(--text-muted);
      margin-top: 8px;
    }

    /* Responsive */

    @media (max-width: 700px) {
      .screen {
        padding: 16px 10px 12px;
        min-height: 88vh;
      }

      .screen-header h1 {
        font-size: 1.35rem;
      }

      .menu-card {
        padding: 16px 14px;
      }

      .hud {
        flex-direction: column;
        align-items: flex-start;
        border-radius: 14px;
      }

      .hud-right {
        align-self: flex-end;
      }

      .mobileHint {
        font-size: 0.75rem;
      }
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <!-- MAIN MENU -->
    <section id="mainMenu" class="screen active">
      <div class="screen-header">
        <h1>Parallax Runner+</h1>
        <p>Cartoon side-scroller with triple jump, power-ups and evolving chaos.</p>
      </div>

      <div class="menu-card">
        <div class="menu-section">
          <div class="menu-section-title">Difficulty</div>
          <div class="difficulty-toggle" id="difficultyToggle">
            <button class="difficulty-btn" data-difficulty="easy">Easy</button>
            <button class="difficulty-btn active" data-difficulty="normal">
              Normal
            </button>
            <button class="difficulty-btn" data-difficulty="hard">Hard</button>
          </div>
          <p class="helper-text">
            Easy = slower world and fewer waves. Hard = faster pace and dense obstacle storms.
            All modes spawn more and more obstacles over time.
          </p>
        </div>

        <div class="menu-section">
          <div class="menu-section-title">Play</div>
          <div class="menu-main-buttons">
            <button id="btnStart" class="btn">Start Game</button>
            <button id="btnInstructions" class="btn btn-ghost">
              Instructions
            </button>
          </div>
        </div>

        <div class="menu-section">
          <div class="menu-section-title">Controls</div>
          <p class="helper-text">
            Desktop: press <span class="kbd">Space</span> to jump
            (up to 3 jumps in mid-air by default).<br />
            Mobile: tap anywhere on the game area.
          </p>
        </div>
      </div>
    </section>

    <!-- INSTRUCTIONS -->
    <section id="instructions" class="screen">
      <div class="screen-header">
        <h1>How to Play</h1>
        <p>Survive, stomp obstacles, grab power-ups and ride through parallax worlds.</p>
      </div>

      <div class="content">
        <div class="instructions-grid">
          <div>
            <h3>Movement</h3>
            <ul>
              <li>
                Your runner moves automatically toward the right side of the
                screen.
              </li>
              <li>
                Press <span class="kbd">Space</span> (or tap on mobile) to jump.
              </li>
              <li>You can chain up to <strong>3 jumps</strong> in the air by default.</li>
              <li>Power-ups can temporarily increase your jump capacity.</li>
            </ul>
          </div>

          <div>
            <h3>Obstacles &amp; Stomp</h3>
            <ul>
              <li>Obstacles come in different shapes and heights: ground, floating and ceiling traps.</li>
              <li>Touching an obstacle from the side or below = instant loss (unless shielded).</li>
              <li>
                If you land on an obstacle from above you
                <strong>stomp</strong> it, destroy it, and get bonus points.
              </li>
              <li>Obstacle intensity grows gradually as time passes.</li>
            </ul>
          </div>

          <div>
            <h3>Power-ups</h3>
            <ul>
              <li><strong>Shield</strong>: absorbs one hit and turns it into a safe smash.</li>
              <li><strong>Jump Boost</strong>: temporarily increases your available jumps.</li>
              <li>Catch power-ups by running through them.</li>
            </ul>
          </div>

          <div>
            <h3>Score</h3>
            <ul>
              <li><strong>+1</strong> point every second you stay alive.</li>
              <li><strong>+1</strong> point for each obstacle destroyed (stomp or shield-hit).</li>
              <li>
                Your total score is shown live in the top-left corner of the
                HUD.
              </li>
            </ul>
          </div>

          <div>
            <h3>Levels &amp; Parallax</h3>
            <ul>
              <li>
                Survive to automatically advance through multiple parallax
                worlds (city, desert, mountains).
              </li>
              <li>
                Each level has its own layered background that scrolls at
                different speeds for a smooth parallax effect.
              </li>
            </ul>
          </div>

          <div>
            <h3>Difficulty</h3>
            <ul>
              <li>
                Choose <strong>Easy / Normal / Hard</strong> from the main menu.
              </li>
              <li>Difficulty controls world speed and base obstacle frequency.</li>
              <li>All difficulties gradually ramp up the number of obstacles.</li>
            </ul>
          </div>
        </div>

        <div class="instructions-footer">
          <button id="btnBackToMenu" class="btn btn-ghost">
            Back to Menu
          </button>
          <button id="btnPlayFromInstructions" class="btn">Play Now</button>
        </div>
      </div>
    </section>

    <!-- GAME -->
    <section id="gameContainer" class="screen">
      <div class="hud">
        <div class="hud-left">
          <div class="hud-pill score">
            SCORE:
            <strong id="scoreDisplay">0</strong>
          </div>
          <div class="hud-pill">
            LEVEL:
            <strong id="levelDisplay">1 – City</strong>
          </div>
          <div class="hud-pill">
            MODE:
            <strong id="difficultyDisplay">Normal</strong>
          </div>
          <div class="hud-pill">
            SHIELD:
            <strong id="shieldDisplay">Off</strong>
          </div>
          <div class="hud-pill">
            JUMP BOOST:
            <strong id="jumpBoostDisplay">-</strong>
          </div>
        </div>
        <div class="hud-right">
          <span class="hud-dot"></span>
          Running
        </div>
      </div>

      <canvas id="gameCanvas" width="960" height="540"></canvas>
      <p class="mobileHint">
        Desktop: press <span class="kbd">Space</span> to jump (up to 3 times by default).<br />
        Mobile: tap anywhere on the game area to jump. Watch the small notepad next to the runner
        to see how many jumps are left.
      </p>
    </section>

    <!-- GAME OVER -->
    <section id="gameOver" class="screen">
      <div class="card">
        <h2>Game Over</h2>
        <p class="gameover-sub">
          The world caught you. Press "Restart", or press Space to try again.
        </p>

        <div class="score-row">
          <span>Final Score</span>
          <strong id="finalScoreDisplay">0</strong>
        </div>
        <div class="score-row">
          <span>Best Score (this session)</span>
          <strong id="bestScoreDisplay">0</strong>
        </div>
        <div class="score-row">
          <span>Obstacles Destroyed</span>
          <strong id="destroyedDisplay">0</strong>
        </div>
        <div class="score-row">
          <span>Time Survived</span>
          <strong id="timeDisplay">0 s</strong>
        </div>

        <div class="gameover-actions">
          <button id="btnRestart" class="btn">Restart</button>
          <button id="btnReturnToMenu" class="btn btn-ghost">
            Return to Main Menu
          </button>
        </div>

        <p class="gameover-label">
          Tip: Use triple jumps and jump boosts to stomp floating traps instead of crashing into them.
        </p>
      </div>
    </section>
  </div>

  <script>
    // ---------- Basic DOM helpers ----------
    const screens = {
      mainMenu: document.getElementById("mainMenu"),
      instructions: document.getElementById("instructions"),
      gameContainer: document.getElementById("gameContainer"),
      gameOver: document.getElementById("gameOver"),
    };
    let currentScreen = "mainMenu";

    function showScreen(key) {
      Object.values(screens).forEach((el) =>
        el.classList.remove("active")
      );
      screens[key].classList.add("active");
      currentScreen = key;
    }

    // ---------- Difficulty ----------
    const difficultyToggle = document.getElementById("difficultyToggle");
    const difficultyButtons =
      difficultyToggle.querySelectorAll(".difficulty-btn");
    const difficultyDisplay = document.getElementById("difficultyDisplay");
    const shieldDisplay = document.getElementById("shieldDisplay");
    const jumpBoostDisplay = document.getElementById("jumpBoostDisplay");

    let difficulty = "normal";

    // Increased obstacle density vs previous version
    const difficultySettings = {
      easy: {
        speed: 260,
        minSpawn: 0.65,
        maxSpawn: 0.95,
      },
      normal: {
        speed: 320,
        minSpawn: 0.45,
        maxSpawn: 0.75,
      },
      hard: {
        speed: 380,
        minSpawn: 0.3,
        maxSpawn: 0.55,
      },
    };

    difficultyButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        difficultyButtons.forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        difficulty = btn.dataset.difficulty;
        difficultyDisplay.textContent =
          difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
      });
    });

    // ---------- Canvas + Game State ----------
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const GAME_WIDTH = canvas.width;
    const GAME_HEIGHT = canvas.height;
    const GROUND_HEIGHT = 120;
    const GROUND_TOP = GAME_HEIGHT - GROUND_HEIGHT;

    const GRAVITY = 2000;
    const JUMP_FORCE = 750;
    const LEVEL_DURATION = 25;
    const BASE_MAX_JUMPS = 3;

    const scoreDisplay = document.getElementById("scoreDisplay");
    const levelDisplay = document.getElementById("levelDisplay");

    const finalScoreDisplay = document.getElementById("finalScoreDisplay");
    const bestScoreDisplay = document.getElementById("bestScoreDisplay");
    const destroyedDisplay = document.getElementById("destroyedDisplay");
    const timeDisplay = document.getElementById("timeDisplay");

    let lastTime = 0;
    let isRunning = false;

    let player;
    let obstacles = [];
    let powerups = [];
    let survivalTime = 0;
    let obstaclesDestroyed = 0;
    let bestScore = 0;

    let obstacleTimer = 0;
    let nextObstacleSpawn = 1;

    let powerTimer = 0;
    let nextPowerSpawn = 8;

    let currentLevelIndex = 0;

    let maxJumps = BASE_MAX_JUMPS;
    let haveShield = false;
    let jumpBoostTime = 0;

    // Running animation (much faster)
    let runAnimationTime = 0;

    const levelThemes = [
      {
        name: "City",
        sky: "#8ed6ff",
        far: "#283593",
        mid: "#3949ab",
        ground: "#43a047",
      },
      {
        name: "Desert",
        sky: "#ffe082",
        far: "#ffb74d",
        mid: "#fb8c00",
        ground: "#f9a825",
      },
      {
        name: "Mountains",
        sky: "#b3e5fc",
        far: "#5c6bc0",
        mid: "#455a64",
        ground: "#4caf50",
      },
    ];

    let parallaxLayers = [];

    function applyLevelTheme() {
      const theme =
        levelThemes[currentLevelIndex % levelThemes.length];

      parallaxLayers = [
        {
          color: theme.far,
          y: GAME_HEIGHT - 260,
          h: 180,
          speedFactor: 0.25,
          offset: 0,
        },
        {
          color: theme.mid,
          y: GAME_HEIGHT - 200,
          h: 180,
          speedFactor: 0.5,
          offset: 0,
        },
        {
          color: theme.ground,
          y: GROUND_TOP,
          h: GROUND_HEIGHT + 20,
          speedFactor: 1.0,
          offset: 0,
        },
      ];

      levelDisplay.textContent = `${currentLevelIndex + 1} – ${
        theme.name
      }`;
    }

    function randRange(min, max) {
      return min + Math.random() * (max - min);
    }

    function computeObstacleSpawnWindow() {
      const settings = difficultySettings[difficulty];
      // Over ~60 seconds, spawn intervals shrink to 40% (more obstacles over time)
      const progress = Math.min(1, survivalTime / 60);
      const factor = 1 - 0.6 * progress; // 1 -> 0.4
      return {
        min: settings.minSpawn * factor,
        max: settings.maxSpawn * factor,
      };
    }

    function resetGameState() {
      const theme = levelThemes[0];
      parallaxLayers = [
        {
          color: theme.far,
          y: GAME_HEIGHT - 260,
          h: 180,
          speedFactor: 0.25,
          offset: 0,
        },
        {
          color: theme.mid,
          y: GAME_HEIGHT - 200,
          h: 180,
          speedFactor: 0.5,
          offset: 0,
        },
        {
          color: theme.ground,
          y: GROUND_TOP,
          h: GROUND_HEIGHT + 20,
          speedFactor: 1.0,
          offset: 0,
        },
      ];

      player = {
        w: 46,
        h: 80,
        x: GAME_WIDTH * 0.2,
        y: GROUND_TOP - 80,
        vy: 0,
        jumpCount: 0,
      };

      obstacles = [];
      powerups = [];
      survivalTime = 0;
      obstaclesDestroyed = 0;
      obstacleTimer = 0;
      powerTimer = 0;
      const spawnWindow = computeObstacleSpawnWindow();
      nextObstacleSpawn = randRange(spawnWindow.min, spawnWindow.max);
      nextPowerSpawn = randRange(6, 11);
      currentLevelIndex = 0;

      maxJumps = BASE_MAX_JUMPS;
      haveShield = false;
      jumpBoostTime = 0;
      applyLevelTheme();
      updateScoreDisplay();
      updatePowerHud();
      runAnimationTime = 0;
    }

    function spawnObstacle() {
      const settings = difficultySettings[difficulty];
      const typeRoll = Math.random();

      let w, h;
      if (typeRoll < 0.4) {
        w = 40;
        h = 50;
      } else if (typeRoll < 0.75) {
        w = 50;
        h = 80;
      } else {
        w = 70;
        h = 40;
      }

      let y;
      const verticalRoll = Math.random();
      let verticalType;
      if (verticalRoll < 0.45) {
        y = GROUND_TOP - h;
        verticalType = "ground";
      } else if (verticalRoll < 0.8) {
        const minY = GROUND_TOP - h - 210;
        const maxY = GROUND_TOP - h - 90;
        y = randRange(Math.max(60, minY), Math.max(80, maxY));
        verticalType = "floating";
      } else {
        y = randRange(40, 110);
        verticalType = "ceiling";
      }

      let shape = "box";
      const shapeRoll = Math.random();
      if (shapeRoll < 0.5) shape = "box";
      else if (shapeRoll < 0.8) shape = "circle";
      else shape = "spike";

      obstacles.push({
        x: GAME_WIDTH + w,
        y,
        w,
        h,
        shape,
        verticalType,
      });

      const spawnWindow = computeObstacleSpawnWindow();
      nextObstacleSpawn = randRange(
        spawnWindow.min,
        spawnWindow.max
      );
    }

    function spawnPowerup() {
      const kindRoll = Math.random();
      const kind = kindRoll < 0.5 ? "shield" : "jump";

      const size = 32;
      const heightRoll = Math.random();
      let y;
      if (heightRoll < 0.33) {
        y = GROUND_TOP - size - 70;
      } else if (heightRoll < 0.66) {
        y = GROUND_TOP - size - 160;
      } else {
        y = randRange(70, GROUND_TOP - size - 140);
      }

      powerups.push({
        x: GAME_WIDTH + 80,
        y,
        w: size,
        h: size,
        kind,
      });

      const progress = Math.min(1, survivalTime / 80);
      const factor = 1 - 0.4 * progress;
      nextPowerSpawn = randRange(7 * factor, 13 * factor);
    }

    function rectsOverlap(a, b) {
      return !(
        a.x + a.w < b.x ||
        a.x > b.x + b.w ||
        a.y + a.h < b.y ||
        a.y > b.y + b.h
      );
    }

    function getDisplayedScore() {
      return Math.floor(survivalTime) + obstaclesDestroyed;
    }

    function updateScoreDisplay() {
      scoreDisplay.textContent = getDisplayedScore();
    }

    function updatePowerHud() {
      shieldDisplay.textContent = haveShield ? "On" : "Off";
      if (jumpBoostTime > 0) {
        jumpBoostDisplay.textContent =
          Math.ceil(jumpBoostTime) + "s";
      } else {
        jumpBoostDisplay.textContent = "-";
      }
    }

    // ---------- Sound (Web Audio beeps) ----------
    let audioCtx = null;
    function playBeep(type) {
      try {
        if (!audioCtx) {
          const AudioContext =
            window.AudioContext || window.webkitAudioContext;
          if (!AudioContext) return;
          audioCtx = new AudioContext();
        }
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        let freq = 440;
        let dur = 0.08;

        switch (type) {
          case "jump":
            freq = 640;
            dur = 0.07;
            break;
          case "stomp":
            freq = 280;
            dur = 0.1;
            break;
          case "hit":
            freq = 140;
            dur = 0.18;
            break;
          case "power":
            freq = 820;
            dur = 0.15;
            break;
        }

        osc.type = "sine";
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.22, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(
          0.001,
          audioCtx.currentTime + dur
        );
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + dur);
      } catch (_) {
        // ignore audio errors
      }
    }

    function applyPowerup(kind) {
      if (kind === "shield") {
        haveShield = true;
      } else if (kind === "jump") {
        jumpBoostTime = 10;
      }
      updatePowerHud();
    }

    function updateGame(dt) {
      if (!isRunning) return;

      const settings = difficultySettings[difficulty];
      const gameSpeed = settings.speed;

      // Level progression
      survivalTime += dt;
      const targetLevel =
        Math.floor(survivalTime / LEVEL_DURATION);
      if (targetLevel !== currentLevelIndex) {
        currentLevelIndex = targetLevel;
        applyLevelTheme();
      }

      // Power timers & max jumps
      if (jumpBoostTime > 0) {
        jumpBoostTime -= dt;
        if (jumpBoostTime < 0) jumpBoostTime = 0;
      }
      maxJumps = jumpBoostTime > 0 ? 5 : BASE_MAX_JUMPS;
      updatePowerHud();

      // Player physics
      const prevBottom = player.y + player.h;

      player.vy += GRAVITY * dt;
      let newY = player.y + player.vy * dt;
      const newBottom = newY + player.h;

      if (newBottom >= GROUND_TOP) {
        newY = GROUND_TOP - player.h;
        player.vy = 0;
        player.jumpCount = 0;
      }

      player.y = newY;

      // Obstacles
      obstacleTimer += dt;
      if (obstacleTimer >= nextObstacleSpawn) {
        spawnObstacle();
        obstacleTimer = 0;
      }

      const playerRect = {
        x: player.x,
        y: player.y,
        w: player.w,
        h: player.h,
      };

      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        o.x -= gameSpeed * dt;

        if (o.x + o.w < -60) {
          obstacles.splice(i, 1);
          continue;
        }
      }

      // Collision and stomp / shield
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];

        if (rectsOverlap(playerRect, o)) {
          const wasAbove = prevBottom <= o.y + 8;
          if (wasAbove && player.vy > 0) {
            obstacles.splice(i, 1);
            obstaclesDestroyed++;
            player.vy = -JUMP_FORCE * 0.7;
            playBeep("stomp");
          } else if (haveShield) {
            haveShield = false;
            updatePowerHud();
            obstacles.splice(i, 1);
            obstaclesDestroyed++;
            playBeep("stomp");
          } else {
            playBeep("hit");
            handleGameOver();
            return;
          }
        }
      }

      // Power-ups
      powerTimer += dt;
      if (powerTimer >= nextPowerSpawn) {
        spawnPowerup();
        powerTimer = 0;
      }

      for (let i = powerups.length - 1; i >= 0; i--) {
        const p = powerups[i];
        p.x -= gameSpeed * dt * 0.8;

        if (p.x + p.w < -60) {
          powerups.splice(i, 1);
          continue;
        }

        if (rectsOverlap(playerRect, p)) {
          applyPowerup(p.kind);
          playBeep("power");
          powerups.splice(i, 1);
        }
      }

      updateScoreDisplay();

      // Parallax background movement
      parallaxLayers.forEach((layer) => {
        layer.offset -= gameSpeed * layer.speedFactor * dt;
        if (layer.offset <= -GAME_WIDTH) {
          layer.offset += GAME_WIDTH;
        }
      });

      // Much faster running animation
      runAnimationTime += dt;
    }

    function drawGame() {
      const theme =
        levelThemes[currentLevelIndex % levelThemes.length];

      // Sky
      ctx.fillStyle = theme.sky;
      ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

      // Parallax layers
      parallaxLayers.forEach((layer) => {
        ctx.fillStyle = layer.color;
        const offset = layer.offset;
        ctx.fillRect(offset, layer.y, GAME_WIDTH, layer.h);
        ctx.fillRect(
          offset + GAME_WIDTH,
          layer.y,
          GAME_WIDTH,
          layer.h
        );
      });

      // Player (simplified runner)
      ctx.save();
      ctx.translate(player.x, player.y);

      // Body
      ctx.fillStyle = "#ffeb3b";
      const torsoW = 26;
      const torsoH = 34;
      const torsoX = (player.w - torsoW) / 2;
      const torsoY = 20;
      ctx.fillRect(torsoX, torsoY, torsoW, torsoH);

      // Head
      ctx.fillStyle = "#ffe082";
      const headSize = 24;
      const headX = (player.w - headSize) / 2;
      const headY = 0;
      if (ctx.roundRect) {
        ctx.beginPath();
        ctx.roundRect(headX, headY, headSize, headSize, 6);
        ctx.fill();
      } else {
        ctx.fillRect(headX, headY, headSize, headSize);
      }

      // Headband
      ctx.fillStyle = "#ff5252";
      ctx.fillRect(headX, headY + 6, headSize, 6);

      // Face
      ctx.fillStyle = "#212121";
      ctx.fillRect(headX + 6, headY + 11, 3, 3);
      ctx.fillRect(headX + 15, headY + 11, 3, 3);
      ctx.beginPath();
      ctx.strokeStyle = "#212121";
      ctx.lineWidth = 1.7;
      ctx.arc(
        headX + headSize / 2,
        headY + 18,
        6,
        0.15 * Math.PI,
        0.85 * Math.PI
      );
      ctx.stroke();

      // Arms (very fast movement)
      const armBaseY = torsoY + 10;
      const armLength = 18;
      const armSwing = Math.sin(runAnimationTime * 40) * 6;

      ctx.strokeStyle = "#ffeb3b";
      ctx.lineWidth = 4;
      ctx.lineCap = "round";

      // Front arm
      ctx.beginPath();
      ctx.moveTo(torsoX + torsoW, armBaseY);
      ctx.lineTo(
        torsoX + torsoW + armLength * 0.9,
        armBaseY + armSwing
      );
      ctx.stroke();

      // Back arm
      ctx.beginPath();
      ctx.moveTo(torsoX, armBaseY + 4);
      ctx.lineTo(
        torsoX - armLength * 0.6,
        armBaseY - armSwing * 0.8
      );
      ctx.stroke();

      // Legs (very fast movement)
      const legBaseY = torsoY + torsoH;
      const legBaseX = player.w / 2;
      const legLength = 26;
      const legSwing = Math.sin(runAnimationTime * 40 + Math.PI) * 8;

      ctx.strokeStyle = "#ffca28";
      ctx.lineWidth = 5;

      // Right leg
      ctx.beginPath();
      ctx.moveTo(legBaseX + 5, legBaseY);
      ctx.lineTo(
        legBaseX + 5 + legSwing,
        legBaseY + legLength
      );
      ctx.stroke();

      // Left leg
      ctx.beginPath();
      ctx.moveTo(legBaseX - 5, legBaseY);
      ctx.lineTo(
        legBaseX - 5 - legSwing,
        legBaseY + legLength
      );
      ctx.stroke();

      ctx.restore();

      // Obstacles
      obstacles.forEach((o) => {
        ctx.save();
        ctx.translate(o.x, o.y);

        let color = "#ff5252";
        if (o.verticalType === "floating") color = "#ff8a65";
        else if (o.verticalType === "ceiling") color = "#ff7043";

        ctx.fillStyle = color;
        ctx.strokeStyle = "rgba(0,0,0,0.6)";
        ctx.lineWidth = 2;

        if (o.shape === "box") {
          ctx.fillRect(0, 0, o.w, o.h);
          ctx.strokeRect(0, 0, o.w, o.h);
        } else if (o.shape === "circle") {
          const r = Math.min(o.w, o.h) / 2;
          ctx.beginPath();
          ctx.arc(o.w / 2, o.h / 2, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        } else {
          ctx.beginPath();
          ctx.moveTo(0, o.h);
          ctx.lineTo(o.w / 2, 0);
          ctx.lineTo(o.w, o.h);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        }

        ctx.restore();
      });

      // Power-ups
      powerups.forEach((p) => {
        ctx.save();
        ctx.translate(p.x, p.y);

        if (p.kind === "shield") {
          ctx.fillStyle = "#40c4ff";
          ctx.strokeStyle = "rgba(0,0,0,0.5)";
          ctx.lineWidth = 2;
          const r = p.w / 2;
          ctx.beginPath();
          ctx.arc(r, r, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();

          ctx.fillStyle = "#ffffff";
          ctx.font = "bold 14px system-ui";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("S", r, r);
        } else if (p.kind === "jump") {
          ctx.fillStyle = "#66bb6a";
          ctx.strokeStyle = "rgba(0,0,0,0.5)";
          ctx.lineWidth = 2;
          const r = 6;
          if (ctx.roundRect) {
            ctx.beginPath();
            ctx.roundRect(0, 0, p.w, p.h, r);
            ctx.fill();
            ctx.stroke();
          } else {
            ctx.fillRect(0, 0, p.w, p.h);
            ctx.strokeRect(0, 0, p.w, p.h);
          }

          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(p.w / 2, p.h - 6);
          ctx.lineTo(p.w / 2, 8);
          ctx.moveTo(p.w / 2, 8);
          ctx.lineTo(p.w / 2 - 5, 13);
          ctx.moveTo(p.w / 2, 8);
          ctx.lineTo(p.w / 2 + 5, 13);
          ctx.stroke();
        }

        ctx.restore();
      });

      // Ground highlight line
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, GROUND_TOP + 1.5);
      ctx.lineTo(GAME_WIDTH, GROUND_TOP + 1.5);
      ctx.stroke();

      // Jump "notepad"
      const jumpsLeft = Math.max(0, maxJumps - player.jumpCount);
      const noteX = player.x + player.w + 12;
      const noteY = player.y + 6;
      const noteW = 90;
      const noteH = 28;

      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(noteX, noteY, noteW, noteH);
      ctx.strokeStyle = "rgba(255,255,255,0.6)";
      ctx.lineWidth = 1.5;
      ctx.strokeRect(noteX, noteY, noteW, noteH);

      ctx.fillStyle = "#ffeb3b";
      ctx.font = "11px system-ui";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.fillText("Jumps", noteX + 8, noteY + 4);
      ctx.fillText("left: " + jumpsLeft, noteX + 8, noteY + 16);
    }

    function gameLoop(timestamp) {
      if (!isRunning) return;

      if (!lastTime) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      updateGame(dt);
      drawGame();

      if (isRunning) {
        requestAnimationFrame(gameLoop);
      }
    }

    function startGame() {
      resetGameState();
      showScreen("gameContainer");
      isRunning = true;
      lastTime = 0;
      requestAnimationFrame(gameLoop);
    }

    function handleGameOver() {
      isRunning = false;
      const finalScore = getDisplayedScore();
      bestScore = Math.max(bestScore, finalScore);

      finalScoreDisplay.textContent = finalScore;
      bestScoreDisplay.textContent = bestScore;
      destroyedDisplay.textContent = obstaclesDestroyed;
      timeDisplay.textContent = `${Math.floor(survivalTime)} s`;

      showScreen("gameOver");
    }

    function restartGame() {
      startGame();
    }

    // ---------- Input ----------
    function tryJump() {
      if (!isRunning) return;
      if (player.jumpCount < maxJumps) {
        player.vy = -JUMP_FORCE;
        player.jumpCount++;
        playBeep("jump");
      }
    }

    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        if (isRunning) {
          tryJump();
        } else if (currentScreen === "gameOver") {
          // Restart with Space on Game Over screen
          restartGame();
        }
      }
    });

    // Mobile tap for jump
    function addTapListener(target) {
      target.addEventListener(
        "touchstart",
        (e) => {
          e.preventDefault();
          tryJump();
        },
        { passive: false }
      );
    }
    addTapListener(canvas);
    addTapListener(document.body);

    // ---------- Buttons ----------
    document.getElementById("btnStart").addEventListener("click", () => {
      startGame();
    });

    document
      .getElementById("btnInstructions")
      .addEventListener("click", () => {
        showScreen("instructions");
      });

    document
      .getElementById("btnBackToMenu")
      .addEventListener("click", () => {
        showScreen("mainMenu");
      });

    document
      .getElementById("btnPlayFromInstructions")
      .addEventListener("click", () => {
        startGame();
      });

    document.getElementById("btnRestart").addEventListener("click", () => {
      restartGame();
    });

    document
      .getElementById("btnReturnToMenu")
      .addEventListener("click", () => {
        showScreen("mainMenu");
      });
  </script>
</body>
</html>
