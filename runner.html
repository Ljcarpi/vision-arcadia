<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Andromadorian Runner – Triple Jump</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg-main: radial-gradient(circle at top, #10172f 0, #020617 55%);
      --panel: rgba(15, 23, 42, 0.96);
      --panel-soft: rgba(15, 23, 42, 0.9);
      --accent: #22c55e;
      --accent-2: #38bdf8;
      --accent-3: #f97316;
      --danger: #f97373;
      --text: #e5f0ff;
      --muted: #9ca3af;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--bg-main);
      color: var(--text);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .app {
      width: 100%;
      max-width: 1200px;
      padding: 12px;
    }

    .view {
      display: none;
      background: radial-gradient(circle at top, #020617 0, #020617 60%, #000 100%);
      border-radius: 20px;
      box-shadow: 0 18px 55px rgba(0, 0, 0, 0.9);
      padding: 18px 14px 16px;
      min-height: min(95vh, 760px);
      position: relative;
      overflow: hidden;
    }

    .view.active {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .view-header {
      text-align: center;
      margin-bottom: 18px;
    }

    .view-header h1 {
      font-size: 2rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--accent-2);
      text-shadow: 0 0 10px rgba(56, 189, 248, 0.9);
      margin-bottom: 4px;
    }

    .view-header p {
      font-size: 0.9rem;
      color: var(--muted);
    }

    /* MENU */

    .card {
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.98), #020617);
      border-radius: 18px;
      padding: 16px;
      max-width: 420px;
      width: 100%;
      border: 1px solid rgba(148, 163, 184, 0.45);
      box-shadow: 0 15px 35px rgba(0, 0, 0, 0.8);
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: "";
      position: absolute;
      inset: -120px;
      background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.16), transparent 60%);
      pointer-events: none;
      opacity: 0.9;
    }

    .card-inner {
      position: relative;
      z-index: 1;
    }

    .section {
      padding: 8px 0;
    }

    .section + .section {
      border-top: 1px dashed rgba(148, 163, 184, 0.35);
      margin-top: 8px;
    }

    .section-title {
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.13em;
      color: var(--muted);
      margin-bottom: 8px;
    }

    .btn {
      border: none;
      border-radius: 999px;
      padding: 10px 16px;
      font-size: 0.98rem;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.07em;
      text-transform: uppercase;
      width: 100%;
      background: linear-gradient(135deg, #22c55e, #4ade80);
      color: #022c22;
      box-shadow: 0 10px 24px rgba(34, 197, 94, 0.65);
      transition:
        transform 0.12s ease,
        box-shadow 0.12s ease,
        filter 0.12s ease;
    }

    .btn:hover {
      transform: translateY(-1px);
      filter: brightness(1.04);
      box-shadow: 0 14px 28px rgba(34, 197, 94, 0.75);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow: 0 7px 18px rgba(34, 197, 94, 0.6);
    }

    .btn-ghost {
      background: transparent;
      color: var(--accent-2);
      border: 1px solid rgba(56, 189, 248, 0.7);
      box-shadow: none;
    }

    .btn-ghost:hover {
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.9);
      background: radial-gradient(circle, rgba(56, 189, 248, 0.12), transparent 65%);
    }

    .btn-danger {
      background: linear-gradient(135deg, #ef4444, #f97373);
      color: #1f0202;
      box-shadow: 0 10px 24px rgba(239, 68, 68, 0.7);
    }

    .btn-row {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 4px;
    }

    .diff-toggle {
      display: flex;
      gap: 6px;
      padding: 3px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.5);
    }

    .diff-btn {
      flex: 1;
      border-radius: 999px;
      border: none;
      font-size: 0.75rem;
      padding: 5px 0;
      cursor: pointer;
      background: transparent;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-weight: 600;
      transition:
        background 0.15s ease,
        color 0.15s ease,
        box-shadow 0.15s ease;
    }

    .diff-btn.active {
      background: linear-gradient(135deg, #38bdf8, #22c55e);
      color: #020617;
      box-shadow: 0 4px 12px rgba(56, 189, 248, 0.7);
    }

    .hint {
      font-size: 0.75rem;
      color: var(--muted);
      margin-top: 6px;
    }

    .kbd {
      display: inline-block;
      padding: 1px 5px;
      border-radius: 4px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.8);
      font-size: 0.75rem;
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo,
        Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    /* INSTRUCTIONS */

    #viewInstructions .card {
      max-width: 680px;
    }

    .instructions-grid {
      display: grid;
      gap: 10px;
      font-size: 0.9rem;
    }

    @media (min-width: 720px) {
      .instructions-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    .instructions-grid h3 {
      font-size: 0.9rem;
      margin-bottom: 3px;
      color: var(--accent-2);
    }

    ul {
      list-style: disc;
      padding-left: 16px;
      color: var(--muted);
    }

    ul li + li {
      margin-top: 3px;
    }

    .footer-row {
      margin-top: 12px;
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      flex-wrap: wrap;
    }

    /* GAME */

    #viewGame {
      align-items: stretch;
      justify-content: flex-start;
      padding: 12px 10px 14px;
      gap: 8px;
    }

    .hud-bar {
      width: 100%;
      max-width: 1120px;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      padding: 6px 9px;
      border-radius: 999px;
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.96), #020617);
      border: 1px solid rgba(148, 163, 184, 0.5);
    }

    .hud-left,
    .hud-right {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 6px;
    }

    .pill {
      border-radius: 999px;
      padding: 3px 8px;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      background: rgba(15, 23, 42, 0.9);
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .pill strong {
      color: var(--accent-2);
    }

    .pill-score {
      background: linear-gradient(135deg, #22c55e, #a3e635);
      color: #022c22;
      box-shadow: 0 0 18px rgba(34, 197, 94, 0.75);
    }

    .pill-score strong {
      color: #022c22;
    }

    .indicator-dot {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: #22c55e;
      box-shadow: 0 0 8px rgba(34, 197, 94, 0.8);
    }

    #gameCanvas {
      margin: 8px auto 0;
      display: block;
      background: #020617;
      width: 100%;
      max-width: 1120px;
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.9);
    }

    .touch-hint {
      margin: 6px auto 0;
      text-align: center;
      font-size: 0.78rem;
      color: var(--muted);
    }

    /* GAME OVER */

    #viewGameOver .card {
      max-width: 420px;
      background: radial-gradient(circle at top, #1e293b 0, #020617 70%);
    }

    .go-title {
      font-size: 1.4rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--danger);
      text-shadow: 0 0 12px rgba(249, 115, 129, 0.9);
      margin-bottom: 2px;
      text-align: center;
    }

    .go-sub {
      font-size: 0.86rem;
      color: var(--muted);
      text-align: center;
      margin-bottom: 10px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.86rem;
      padding: 2px 0;
      color: var(--muted);
    }

    .stat-row strong {
      color: var(--accent-2);
    }

    .go-tip {
      font-size: 0.76rem;
      text-align: center;
      margin-top: 8px;
      color: var(--muted);
    }

    @media (max-width: 760px) {
      .view {
        padding: 14px 10px 10px;
        min-height: 90vh;
      }
      .view-header h1 {
        font-size: 1.5rem;
      }
      .hud-bar {
        flex-direction: column;
        align-items: flex-start;
        border-radius: 14px;
      }
      .hud-right {
        justify-content: flex-end;
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- MAIN MENU -->
    <section id="viewMenu" class="view active">
      <div class="view-header">
        <h1>ANDROMADORIAN RUNNER</h1>
        <p>Triple-jump runner with evolving chaos, power-ups and parallax worlds.</p>
      </div>

      <div class="card">
        <div class="card-inner">
          <div class="section">
            <div class="section-title">Difficulty</div>
            <div class="diff-toggle" id="diffToggle">
              <button class="diff-btn" data-mode="easy">Easy</button>
              <button class="diff-btn active" data-mode="normal">Normal</button>
              <button class="diff-btn" data-mode="hard">Hard</button>
            </div>
            <p class="hint">
              Higher difficulty = faster world and denser obstacle waves.
              All modes ramp up over time.
            </p>
          </div>

          <div class="section">
            <div class="section-title">Play</div>
            <div class="btn-row">
              <button id="btnPlay" class="btn">Start Run</button>
              <button id="btnInstructions" class="btn btn-ghost">How to Play</button>
            </div>
          </div>

          <div class="section">
            <div class="section-title">Controls</div>
            <p class="hint">
              Desktop: press <span class="kbd">Space</span> to jump (up to 3 jumps in mid-air),
              <span class="kbd">Shift</span> to drop down from a platform.<br />
              Mobile: tap on the game area to jump.
            </p>
          </div>
        </div>
      </div>
    </section>

    <!-- INSTRUCTIONS -->
    <section id="viewInstructions" class="view">
      <div class="view-header">
        <h1>Andromadorian Runner – How to Play</h1>
        <p>Survive, stomp obstacles, grab power-ups and ride across stacked platforms.</p>
      </div>

      <div class="card">
        <div class="card-inner">
          <div class="instructions-grid">
            <div>
              <h3>Movement</h3>
              <ul>
                <li>Your runner auto-moves to the right.</li>
                <li>Press <span class="kbd">Space</span> or tap to jump.</li>
                <li>You can chain up to <strong>3 jumps</strong> by default.</li>
                <li>Landing on the ground or platforms restores all jumps.</li>
                <li>Stomping an obstacle from above also restores all jumps.</li>
                <li>
                  Press <span class="kbd">Shift</span> while standing on a platform to
                  drop down through it (no gap required).
                </li>
                <li>There is a ceiling: you cannot go higher than the top limit.</li>
              </ul>
            </div>

            <div>
              <h3>Obstacles</h3>
              <ul>
                <li>Different shapes and heights: ground, floating and ceiling traps.</li>
                <li>Some obstacles move horizontally as they slide in.</li>
                <li>Touching an obstacle from the side or below = instant defeat (unless shielded).</li>
                <li>Obstacle spawn rate grows the longer you survive.</li>
              </ul>
            </div>

            <div>
              <h3>Power-ups</h3>
              <ul>
                <li><strong>Shield</strong>: blocks one hit and turns it into a smash.</li>
                <li><strong>Jump Boost</strong>: temporarily increases max jumps.</li>
                <li><strong>Score Burst</strong>: injects bonus score instantly.</li>
                <li><strong>Slow Time</strong>: slows the world speed for a short time.</li>
                <li>Run through power-ups to collect them.</li>
              </ul>
            </div>

            <div>
              <h3>Score</h3>
              <ul>
                <li><strong>+1</strong> point every second you stay alive.</li>
                <li><strong>+1</strong> point for each obstacle destroyed.</li>
                <li>Power-ups may give extra score.</li>
                <li>Live score is shown in the HUD at the top.</li>
              </ul>
            </div>

            <div>
              <h3>Levels &amp; Parallax</h3>
              <ul>
                <li>Run through several parallax worlds (neon city, dunes, mountains).</li>
                <li>Each world has animated sky, foreground and ground layers.</li>
                <li>Three floors of platforms let you route above or below.</li>
              </ul>
            </div>

            <div>
              <h3>Difficulty</h3>
              <ul>
                <li>Select Easy / Normal / Hard in the main menu.</li>
                <li>Changes game speed and base obstacle frequency.</li>
                <li>All modes gradually become more intense.</li>
              </ul>
            </div>
          </div>

          <div class="footer-row">
            <button id="btnBackMenu" class="btn btn-ghost">Back to Menu</button>
            <button id="btnPlayFromInstructions" class="btn">Start Run</button>
          </div>
        </div>
      </div>
    </section>

    <!-- GAME -->
    <section id="viewGame" class="view">
      <div class="hud-bar">
        <div class="hud-left">
          <div class="pill pill-score">
            SCORE:<strong id="scoreText">0</strong>
          </div>
          <div class="pill">
            LEVEL:<strong id="levelText">1 – City</strong>
          </div>
          <div class="pill">
            MODE:<strong id="modeText">Normal</strong>
          </div>
          <div class="pill">
            SHIELD:<strong id="shieldText">Off</strong>
          </div>
          <div class="pill">
            JUMP BOOST:<strong id="jumpBoostText">-</strong>
          </div>
          <div class="pill">
            BONUS:<strong id="bonusText">0</strong>
          </div>
          <div class="pill">
            SLOW:<strong id="slowText">Off</strong>
          </div>
        </div>
        <div class="hud-right">
          <span class="indicator-dot"></span>
          <span style="font-size: 0.75rem; color: var(--muted); text-transform: uppercase; letter-spacing: 0.12em;">
            RUNNING
          </span>
        </div>
      </div>

      <canvas id="gameCanvas" width="960" height="540"></canvas>
      <p class="touch-hint">
        Space / tap = jump (up to 3 jumps by default). Shift = drop down from platforms.<br />
        Stomp obstacles from above to refill jumps and gain points.
      </p>
    </section>

    <!-- GAME OVER -->
    <section id="viewGameOver" class="view">
      <div class="card">
        <div class="card-inner">
          <div class="go-title">RUN ENDED</div>
          <p class="go-sub">
            Press <strong>Restart</strong> or hit <span class="kbd">Space</span> to jump back in.
          </p>

          <div class="stat-row">
            <span>Final Score</span>
            <strong id="finalScoreText">0</strong>
          </div>
          <div class="stat-row">
            <span>Best (session)</span>
            <strong id="bestScoreText">0</strong>
          </div>
          <div class="stat-row">
            <span>Obstacles Destroyed</span>
            <strong id="destroyedText">0</strong>
          </div>
          <div class="stat-row">
            <span>Time Survived</span>
            <strong id="timeText">0 s</strong>
          </div>

          <div class="btn-row" style="margin-top: 10px;">
            <button id="btnRestart" class="btn">Restart</button>
            <button id="btnGoMenu" class="btn btn-ghost">Main Menu</button>
          </div>

          <p class="go-tip">
            Tip: Use upper floors to dodge dense waves, drop with Shift, and stomp to keep your triple jump alive.
          </p>
        </div>
      </div>
    </section>
  </div>

  <script>
    // AUDIO:
    // Coloca un archivo MP3 de música de partida en:
    // /assets/audio/game-start.mp3
    // Se reproducirá en loop SOLO mientras la partida esté en curso.
    const bgMusic = new Audio("assets/audio/game-start.mp3");
    bgMusic.loop = true;

    let audioCtx = null;

    function ensureAudioContext() {
      if (!audioCtx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (!AC) return;
        audioCtx = new AC();
      }
      if (audioCtx && audioCtx.state === "suspended") {
        audioCtx.resume().catch(() => {});
      }
    }

    function playMusic() {
      try {
        ensureAudioContext();
        bgMusic.currentTime = 0;
        bgMusic.play().catch(() => {});
      } catch (_) {}
    }

    function stopMusic() {
      try {
        bgMusic.pause();
      } catch (_) {}
    }

    function playBeep(type) {
      try {
        ensureAudioContext();
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        let freq = 440;
        let dur = 0.08;

        switch (type) {
          case "jump":
            freq = 820;
            dur = 0.06;
            break;
          case "stomp":
            freq = 260;
            dur = 0.1;
            break;
          case "hit":
            freq = 140;
            dur = 0.15;
            break;
          case "power":
            freq = 1000;
            dur = 0.12;
            break;
        }

        osc.type = "sine";
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.24, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(
          0.001,
          audioCtx.currentTime + dur
        );
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + dur);
      } catch (_) {}
    }

    // VIEWS

    const views = {
      menu: document.getElementById("viewMenu"),
      instructions: document.getElementById("viewInstructions"),
      game: document.getElementById("viewGame"),
      gameOver: document.getElementById("viewGameOver"),
    };
    let currentView = "menu";

    function showView(id) {
      Object.values(views).forEach((v) => v.classList.remove("active"));
      views[id].classList.add("active");
      currentView = id;
    }

    // DIFFICULTY

    const diffToggle = document.getElementById("diffToggle");
    const diffButtons = diffToggle.querySelectorAll(".diff-btn");
    const modeText = document.getElementById("modeText");

    let difficulty = "normal";

    const difficultySettings = {
      easy: { speed: 260, minSpawn: 0.55, maxSpawn: 0.8 },
      normal: { speed: 320, minSpawn: 0.38, maxSpawn: 0.6 },
      hard: { speed: 380, minSpawn: 0.24, maxSpawn: 0.45 },
    };

    diffButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        diffButtons.forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        difficulty = btn.dataset.mode;
        modeText.textContent =
          difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
      });
    });

    // GAME CONSTANTS & STATE

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const WORLD_WIDTH = canvas.width;
    const WORLD_HEIGHT = canvas.height;
    const GROUND_HEIGHT = 120;
    const GROUND_Y = WORLD_HEIGHT - GROUND_HEIGHT;
    const CEILING_Y = 30; // top limit for the runner

    const GRAVITY = 2000;
    const JUMP_FORCE = 750;
    const BASE_MAX_JUMPS = 3;
    const LEVEL_DURATION = 25;

    const PLATFORM_LENGTH = 260;
    const PLATFORM_GAP = 180;
    const PLATFORM_BANDS = 3;

    // HUD refs
    const scoreText = document.getElementById("scoreText");
    const levelText = document.getElementById("levelText");
    const shieldText = document.getElementById("shieldText");
    const jumpBoostText = document.getElementById("jumpBoostText");
    const bonusText = document.getElementById("bonusText");
    const slowText = document.getElementById("slowText");

    const finalScoreText = document.getElementById("finalScoreText");
    const bestScoreText = document.getElementById("bestScoreText");
    const destroyedText = document.getElementById("destroyedText");
    const timeText = document.getElementById("timeText");

    let isRunning = false;
    let lastTime = 0;

    let player;
    let obstacles = [];
    let powerups = [];
    let platforms = [];

    let survivalTime = 0;
    let obstaclesDestroyed = 0;
    let bonusScore = 0;
    let bestScore = 0;

    let obstacleTimer = 0;
    let nextObstacleSpawn = 1;

    let powerTimer = 0;
    let nextPowerSpawn = 8;

    let currentLevel = 0;

    let maxJumps = BASE_MAX_JUMPS;
    let shieldActive = false;
    let jumpBoostTime = 0;
    let slowTime = 0;
    let speedFactor = 1;

    let runAnimTime = 0;

    // Drop-through control
    let dropRequested = false;

    // Runner head image
    const faceImg = new Image();
    faceImg.src = "assets/faces/face1.png";

    const themes = [
      {
        name: "City",
        sky: "#020617",
        skyGlow: "#38bdf8",
        far: "#0f172a",
        mid: "#1f2937",
        ground: "#16a34a",
      },
      {
        name: "Dunes",
        sky: "#0b1120",
        skyGlow: "#f97316",
        far: "#9a3412",
        mid: "#c2410c",
        ground: "#fbbf24",
      },
      {
        name: "Peaks",
        sky: "#020617",
        skyGlow: "#a855f7",
        far: "#1f2937",
        mid: "#374151",
        ground: "#22c55e",
      },
    ];

    let parallaxLayers = [];

    function applyTheme() {
      const theme = themes[currentLevel % themes.length];

      parallaxLayers = [
        {
          color: theme.far,
          y: WORLD_HEIGHT - 320,
          h: 220,
          speedFactor: 0.25,
          offset: 0,
        },
        {
          color: theme.mid,
          y: WORLD_HEIGHT - 250,
          h: 200,
          speedFactor: 0.5,
          offset: 0,
        },
        {
          color: theme.ground,
          y: GROUND_Y,
          h: GROUND_HEIGHT + 40,
          speedFactor: 1,
          offset: 0,
        },
      ];

      levelText.textContent = `${currentLevel + 1} – ${theme.name}`;
    }

    function initPlatforms() {
      platforms = [];

      const bands = [
        { y: GROUND_Y - 110, offset: 80 },
        { y: GROUND_Y - 220, offset: 260 },
        { y: GROUND_Y - 330, offset: 440 },
      ];

      bands.forEach((band, index) => {
        for (let i = 0; i < 3; i++) {
          platforms.push({
            x: band.offset + i * (PLATFORM_LENGTH + PLATFORM_GAP),
            y: band.y,
            w: PLATFORM_LENGTH,
            h: 18,
            band: index,
          });
        }
      });
    }

    function rand(min, max) {
      return min + Math.random() * (max - min);
    }

    function obstacleSpawnWindow() {
      const cfg = difficultySettings[difficulty];
      const progress = Math.min(1, survivalTime / 60);
      const factor = 1 - 0.65 * progress; // 1 -> 0.35
      return {
        min: cfg.minSpawn * factor,
        max: cfg.maxSpawn * factor,
      };
    }

    function resetGameState() {
      const theme = themes[0];
      parallaxLayers = [
        {
          color: theme.far,
          y: WORLD_HEIGHT - 320,
          h: 220,
          speedFactor: 0.25,
          offset: 0,
        },
        {
          color: theme.mid,
          y: WORLD_HEIGHT - 250,
          h: 200,
          speedFactor: 0.5,
          offset: 0,
        },
        {
          color: theme.ground,
          y: GROUND_Y,
          h: GROUND_HEIGHT + 40,
          speedFactor: 1,
          offset: 0,
        },
      ];

      // Runner: más bajo y más cuadrado
      player = {
        w: 30,
        h: 36,
        x: WORLD_WIDTH * 0.16,
        y: GROUND_Y - 36,
        vy: 0,
        jumpsUsed: 0,
      };

      initPlatforms();

      obstacles = [];
      powerups = [];

      survivalTime = 0;
      obstaclesDestroyed = 0;
      bonusScore = 0;

      obstacleTimer = 0;
      powerTimer = 0;
      const windowSpawn = obstacleSpawnWindow();
      nextObstacleSpawn = rand(windowSpawn.min, windowSpawn.max);
      nextPowerSpawn = rand(6, 11);

      currentLevel = 0;
      maxJumps = BASE_MAX_JUMPS;
      shieldActive = false;
      jumpBoostTime = 0;
      slowTime = 0;
      speedFactor = 1;
      applyTheme();
      updateScoreHUD();
      updatePowerHUD();
      runAnimTime = 0;
      dropRequested = false;
    }

    function spawnObstacle() {
      const typeRoll = Math.random();

      let w, h;
      if (typeRoll < 0.4) {
        w = 34;
        h = 40;
      } else if (typeRoll < 0.75) {
        w = 42;
        h = 60;
      } else {
        w = 58;
        h = 32;
      }

      const verticalRoll = Math.random();
      let y;
      let vType;
      if (verticalRoll < 0.45) {
        y = GROUND_Y - h;
        vType = "ground";
      } else if (verticalRoll < 0.8) {
        const minY = GROUND_Y - h - 220;
        const maxY = GROUND_Y - h - 100;
        y = rand(Math.max(60, minY), Math.max(80, maxY));
        vType = "mid";
      } else {
        y = rand(40, 150);
        vType = "ceiling";
      }

      let shape = "box";
      const shapeRoll = Math.random();
      if (shapeRoll < 0.5) shape = "box";
      else if (shapeRoll < 0.8) shape = "circle";
      else shape = "spike";

      // Movimiento horizontal opcional
      let moveType = "static";
      let amplitude = 0;
      let moveSpeed = 0;
      let phase = 0;
      const moveRoll = Math.random();
      if (moveRoll < 0.35) {
        moveType = "hmove";
        amplitude = rand(15, 42);
        moveSpeed = rand(3.5, 7);
        phase = Math.random() * Math.PI * 2;
      }

      const baseX = WORLD_WIDTH + w;

      obstacles.push({
        baseX,
        x: baseX,
        y,
        w,
        h,
        shape,
        vType,
        moveType,
        amplitude,
        moveSpeed,
        phase,
        offsetX: 0,
      });

      const windowSpawn = obstacleSpawnWindow();
      nextObstacleSpawn = rand(windowSpawn.min, windowSpawn.max);
    }

    function spawnPowerup() {
      const kinds = ["shield", "jump", "score", "slow"];
      const kind = kinds[Math.floor(Math.random() * kinds.length)];

      const size = 32;
      const roll = Math.random();
      let y;
      if (roll < 0.33) {
        y = GROUND_Y - size - 60;
      } else if (roll < 0.66) {
        y = GROUND_Y - size - 160;
      } else {
        y = rand(90, GROUND_Y - size - 180);
      }

      powerups.push({
        x: WORLD_WIDTH + 80,
        y,
        w: size,
        h: size,
        kind,
      });

      const progress = Math.min(1, survivalTime / 80);
      const factor = 1 - 0.4 * progress;
      nextPowerSpawn = rand(7 * factor, 13 * factor);
    }

    function rectsOverlap(a, b) {
      return !(
        a.x + a.w < b.x ||
        a.x > b.x + b.w ||
        a.y + a.h < b.y ||
        a.y > b.y + b.h
      );
    }

    function liveScore() {
      return Math.floor(survivalTime) + obstaclesDestroyed + bonusScore;
    }

    function updateScoreHUD() {
      scoreText.textContent = liveScore();
    }

    function updatePowerHUD() {
      shieldText.textContent = shieldActive ? "On" : "Off";
      jumpBoostText.textContent =
        jumpBoostTime > 0 ? Math.ceil(jumpBoostTime) + "s" : "-";
      bonusText.textContent = bonusScore;
      slowText.textContent = slowTime > 0 ? "On" : "Off";
    }

    function applyPower(kind) {
      if (kind === "shield") {
        shieldActive = true;
      } else if (kind === "jump") {
        jumpBoostTime = 10;
      } else if (kind === "score") {
        bonusScore += 10;
      } else if (kind === "slow") {
        slowTime = 6;
        speedFactor = 0.6;
      }
      updatePowerHUD();
    }

    function updatePlatforms(dt, gameSpeed) {
      for (let band = 0; band < PLATFORM_BANDS; band++) {
        let maxX = -Infinity;
        platforms.forEach((p) => {
          if (p.band === band && p.x > maxX) {
            maxX = p.x;
          }
        });

        platforms.forEach((p) => {
          if (p.band !== band) return;
          p.x -= gameSpeed * dt;
          if (p.x + p.w < -120) {
            p.x = maxX + PLATFORM_LENGTH + PLATFORM_GAP;
            maxX = p.x;
          }
        });
      }
    }

    function updateGame(dt) {
      if (!isRunning) return;

      if (jumpBoostTime > 0) {
        jumpBoostTime -= dt;
        if (jumpBoostTime < 0) jumpBoostTime = 0;
      }
      if (slowTime > 0) {
        slowTime -= dt;
        if (slowTime <= 0) {
          slowTime = 0;
          speedFactor = 1;
        }
      }
      maxJumps = jumpBoostTime > 0 ? 5 : BASE_MAX_JUMPS;
      updatePowerHUD();

      const cfg = difficultySettings[difficulty];
      const worldSpeed = cfg.speed * speedFactor;

      // Tiempo & niveles
      survivalTime += dt;
      const targetLevel = Math.floor(survivalTime / LEVEL_DURATION);
      if (targetLevel !== currentLevel) {
        currentLevel = targetLevel;
        applyTheme();
      }

      // Física del jugador
      const prevBottom = player.y + player.h;

      player.vy += GRAVITY * dt;
      let newY = player.y + player.vy * dt;
      let newBottom = newY + player.h;

      // Tope superior (techo): no puede superar el techo, pero no pierde
      if (newY < CEILING_Y) {
        newY = CEILING_Y;
        newBottom = newY + player.h;
        if (player.vy < 0) player.vy = 0;
      }

      let onPlatform = false;

      // Plataformas (desde arriba), considerando drop con Shift
      for (let i = 0; i < platforms.length; i++) {
        const pf = platforms[i];
        const top = pf.y;
        const overlapX =
          player.x + player.w > pf.x &&
          player.x < pf.x + pf.w;

        // Drop a través de plataforma
        if (
          dropRequested &&
          overlapX &&
          prevBottom >= top - 2 &&
          prevBottom <= top + 6
        ) {
          // ignorar esta plataforma este frame
          continue;
        }

        if (
          overlapX &&
          prevBottom <= top &&
          newBottom >= top
        ) {
          newY = top - player.h;
          newBottom = newY + player.h;
          player.vy = 0;
          player.jumpsUsed = 0;
          onPlatform = true;
          break;
        }
      }

      // Suelo
      if (!onPlatform && newBottom >= GROUND_Y) {
        newY = GROUND_Y - player.h;
        newBottom = newY + player.h;
        player.vy = 0;
        player.jumpsUsed = 0;
      }

      player.y = newY;

      // Plataformas movimiento
      updatePlatforms(dt, worldSpeed);

      // Obstáculos
      obstacleTimer += dt;
      if (obstacleTimer >= nextObstacleSpawn) {
        spawnObstacle();
        obstacleTimer = 0;
      }

      const playerRect = {
        x: player.x,
        y: player.y,
        w: player.w,
        h: player.h,
      };

      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        o.baseX -= worldSpeed * dt;
        if (o.moveType === "hmove") {
          o.phase += o.moveSpeed * dt;
          o.offsetX = Math.sin(o.phase) * o.amplitude;
        } else {
          o.offsetX = 0;
        }
        o.x = o.baseX + o.offsetX;

        if (o.baseX + o.w < -80) {
          obstacles.splice(i, 1);
          continue;
        }
      }

      // Colisiones con obstáculos
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        if (!rectsOverlap(playerRect, o)) continue;

        const wasAbove = prevBottom <= o.y + 8;
        if (wasAbove && player.vy > 0) {
          obstacles.splice(i, 1);
          obstaclesDestroyed++;
          player.vy = -JUMP_FORCE * 0.7;
          player.jumpsUsed = 0; // recarga saltos al stomp
          playBeep("stomp");
        } else if (shieldActive) {
          shieldActive = false;
          obstacles.splice(i, 1);
          obstaclesDestroyed++;
          playBeep("stomp");
          updatePowerHUD();
        } else {
          playBeep("hit");
          endGame();
          return;
        }
      }

      // Power-ups
      powerTimer += dt;
      if (powerTimer >= nextPowerSpawn) {
        spawnPowerup();
        powerTimer = 0;
      }

      for (let i = powerups.length - 1; i >= 0; i--) {
        const p = powerups[i];
        p.x -= worldSpeed * dt * 0.85;

        if (p.x + p.w < -80) {
          powerups.splice(i, 1);
          continue;
        }

        if (rectsOverlap(playerRect, p)) {
          applyPower(p.kind);
          playBeep("power");
          powerups.splice(i, 1);
        }
      }

      // Parallax
      parallaxLayers.forEach((layer) => {
        layer.offset -= worldSpeed * layer.speedFactor * dt;
        if (layer.offset <= -WORLD_WIDTH) {
          layer.offset += WORLD_WIDTH;
        }
      });

      // Animación de correr
      runAnimTime += dt;
      updateScoreHUD();

      // Drop-request se consume en este frame
      dropRequested = false;
    }

    // DIBUJO

    function drawSky(theme) {
      const gradient = ctx.createLinearGradient(
        0,
        0,
        0,
        WORLD_HEIGHT
      );
      gradient.addColorStop(0, theme.skyGlow);
      gradient.addColorStop(0.25, theme.sky);
      gradient.addColorStop(1, "#020617");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

      // Estrellas / glow
      ctx.save();
      ctx.fillStyle = "rgba(148, 163, 184, 0.7)";
      for (let i = 0; i < 50; i++) {
        const x = (i * 180 + survivalTime * 45) % (WORLD_WIDTH + 200) - 100;
        const y = (i * 70) % 160 + 10;
        const s = 1 + (i % 3);
        ctx.globalAlpha = 0.2 + 0.6 * ((i % 5) / 4);
        ctx.fillRect(x, y, s, s);
      }
      ctx.restore();

      // Luna / sol estilizado
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = theme.skyGlow;
      ctx.beginPath();
      ctx.arc(WORLD_WIDTH * 0.1, 70, 36, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Línea visual de techo
      ctx.save();
      ctx.strokeStyle = "rgba(148, 163, 184, 0.4)";
      ctx.setLineDash([6, 6]);
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, CEILING_Y);
      ctx.lineTo(WORLD_WIDTH, CEILING_Y);
      ctx.stroke();
      ctx.restore();
    }

    function drawDecor(theme) {
      ctx.save();
      if (theme.name === "City") {
        const baseY = WORLD_HEIGHT - 260;
        for (let i = 0; i < 12; i++) {
          const w = 60;
          const h = 80 + (i % 3) * 26;
          const x =
            (i * 100 - (survivalTime * 40) % 100) - 40;
          ctx.fillStyle = i % 2 === 0 ? theme.far : theme.mid;
          ctx.fillRect(x, baseY + 130 - h, w, h);

          // windows
          ctx.fillStyle = "rgba(250, 250, 210, 0.7)";
          for (let r = 0; r < 4; r++) {
            for (let c = 0; c < 2; c++) {
              if ((r + c + i) % 2 === 0) continue;
              const wx = x + 8 + c * 24;
              const wy = baseY + 124 - h + r * 16;
              ctx.fillRect(wx, wy, 10, 7);
            }
          }
        }
      } else if (theme.name === "Dunes") {
        const baseY = WORLD_HEIGHT - 240;
        ctx.fillStyle = theme.far;
        for (let i = 0; i < 4; i++) {
          const w = 260;
          const x =
            (i * 260 - (survivalTime * 30) % 260) - 80;
          ctx.beginPath();
          ctx.moveTo(x, baseY + 90);
          ctx.quadraticCurveTo(
            x + w / 2,
            baseY - 10,
            x + w,
            baseY + 90
          );
          ctx.lineTo(x + w, WORLD_HEIGHT);
          ctx.lineTo(x, WORLD_HEIGHT);
          ctx.closePath();
          ctx.fill();
        }
      } else {
        // Mountains
        const baseY = WORLD_HEIGHT - 250;
        ctx.fillStyle = theme.far;
        for (let i = 0; i < 5; i++) {
          const w = 220;
          const x =
            (i * 220 - (survivalTime * 25) % 220) - 80;
          ctx.beginPath();
          ctx.moveTo(x, baseY + 130);
          ctx.lineTo(x + w / 2, baseY - 10);
          ctx.lineTo(x + w, baseY + 130);
          ctx.closePath();
          ctx.fill();
        }
      }
      ctx.restore();
    }

    function drawGame() {
      const theme = themes[currentLevel % themes.length];

      drawSky(theme);
      drawDecor(theme);

      // Parallax layers
      parallaxLayers.forEach((layer) => {
        ctx.fillStyle = layer.color;
        const off = layer.offset;
        ctx.fillRect(off, layer.y, WORLD_WIDTH, layer.h);
        ctx.fillRect(off + WORLD_WIDTH, layer.y, WORLD_WIDTH, layer.h);
      });

      // Plataformas
      ctx.save();
      ctx.fillStyle = "rgba(15, 23, 42, 0.95)";
      ctx.strokeStyle = "rgba(148, 163, 184, 0.9)";
      ctx.lineWidth = 2;
      platforms.forEach((p) => {
        ctx.fillRect(p.x, p.y, p.w, p.h);
        ctx.strokeRect(p.x, p.y, p.w, p.h);
      });
      ctx.restore();

      // Runner (más bajo y cuadrado)
      ctx.save();
      ctx.translate(player.x, player.y);

      // torso
      const torsoW = 16;
      const torsoH = 17;
      const torsoX = (player.w - torsoW) / 2;
      const torsoY = 14;
      ctx.fillStyle = "#22c55e";
      ctx.fillRect(torsoX, torsoY, torsoW, torsoH);

      // head (PNG en /assets/faces/face1.png con fallback)
      const headSize = 30;
      const headX = (player.w - headSize) / 2;
      const headY = 2;
      if (faceImg.complete && faceImg.naturalWidth) {
        ctx.drawImage(faceImg, headX, headY, headSize, headSize);
      } else {
        ctx.fillStyle = "#facc15";
        if (ctx.roundRect) {
          ctx.beginPath();
          ctx.roundRect(headX, headY, headSize, headSize, 4);
          ctx.fill();
        } else {
          ctx.fillRect(headX, headY, headSize, headSize);
        }
        ctx.fillStyle = "#0f172a";
        ctx.fillRect(headX + 2, headY + 4, headSize - 4, 5);
      }

      // arms (muy rápidos)
      const armBaseY = torsoY + 7;
      const armLen = 12;
      const armSwing = Math.sin(runAnimTime * 90) * 5;
      ctx.strokeStyle = "#22c55e";
      ctx.lineCap = "round";
      ctx.lineWidth = 3;

      // front arm
      ctx.beginPath();
      ctx.moveTo(torsoX + torsoW, armBaseY);
      ctx.lineTo(
        torsoX + torsoW + armLen * 0.9,
        armBaseY + armSwing
      );
      ctx.stroke();

      // back arm
      ctx.beginPath();
      ctx.moveTo(torsoX, armBaseY + 3);
      ctx.lineTo(
        torsoX - armLen * 0.6,
        armBaseY - armSwing * 0.8
      );
      ctx.stroke();

      // legs (muy rápidos)
      const legBaseY = torsoY + torsoH;
      const legBaseX = player.w / 2;
      const legLen = 10;
      const legSwing = Math.sin(runAnimTime * 90 + Math.PI) * 7;

      ctx.strokeStyle = "#4ade80";
      ctx.lineWidth = 4;

      // right leg
      ctx.beginPath();
      ctx.moveTo(legBaseX + 2, legBaseY);
      ctx.lineTo(
        legBaseX + 2 + legSwing,
        legBaseY + legLen
      );
      ctx.stroke();

      // left leg
      ctx.beginPath();
      ctx.moveTo(legBaseX - 2, legBaseY);
      ctx.lineTo(
        legBaseX - 2 - legSwing,
        legBaseY + legLen
      );
      ctx.stroke();

      ctx.restore();

      // Obstáculos
      obstacles.forEach((o) => {
        ctx.save();
        ctx.translate(o.x, o.y);

        let color = "#f97373";
        if (o.vType === "mid") color = "#fb923c";
        if (o.vType === "ceiling") color = "#facc15";

        ctx.fillStyle = color;
        ctx.strokeStyle = "rgba(15, 23, 42, 0.9)";
        ctx.lineWidth = 2;

        if (o.shape === "box") {
          ctx.fillRect(0, 0, o.w, o.h);
          ctx.strokeRect(0, 0, o.w, o.h);
        } else if (o.shape === "circle") {
          const r = Math.min(o.w, o.h) / 2;
          ctx.beginPath();
          ctx.arc(o.w / 2, o.h / 2, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        } else {
          ctx.beginPath();
          ctx.moveTo(0, o.h);
          ctx.lineTo(o.w / 2, 0);
          ctx.lineTo(o.w, o.h);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        }

        ctx.restore();
      });

      // Power-ups
      powerups.forEach((p) => {
        ctx.save();
        ctx.translate(p.x, p.y);

        if (p.kind === "shield") {
          ctx.fillStyle = "#38bdf8";
          ctx.strokeStyle = "#0f172a";
          ctx.lineWidth = 2;
          const r = p.w / 2;
          ctx.beginPath();
          ctx.arc(r, r, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = "#e5f0ff";
          ctx.font = "bold 14px system-ui";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("S", r, r);
        } else if (p.kind === "jump") {
          ctx.fillStyle = "#22c55e";
          ctx.strokeStyle = "#052e16";
          ctx.lineWidth = 2;
          const radius = 6;
          if (ctx.roundRect) {
            ctx.beginPath();
            ctx.roundRect(0, 0, p.w, p.h, radius);
            ctx.fill();
            ctx.stroke();
          } else {
            ctx.fillRect(0, 0, p.w, p.h);
            ctx.strokeRect(0, 0, p.w, p.h);
          }
          ctx.strokeStyle = "#e5f0ff";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(p.w / 2, p.h - 6);
          ctx.lineTo(p.w / 2, 8);
          ctx.moveTo(p.w / 2, 8);
          ctx.lineTo(p.w / 2 - 5, 13);
          ctx.moveTo(p.w / 2, 8);
          ctx.lineTo(p.w / 2 + 5, 13);
          ctx.stroke();
        } else if (p.kind === "score") {
          ctx.fillStyle = "#facc15";
          ctx.strokeStyle = "#451a03";
          ctx.lineWidth = 2;
          const cx = p.w / 2;
          const cy = p.h / 2;
          const outer = 14;
          const inner = 6;
          ctx.beginPath();
          for (let i = 0; i < 10; i++) {
            const angle = (i * Math.PI) / 5;
            const r = i % 2 === 0 ? outer : inner;
            const x = cx + Math.cos(angle) * r;
            const y = cy + Math.sin(angle) * r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        } else if (p.kind === "slow") {
          ctx.fillStyle = "#a855f7";
          ctx.strokeStyle = "#4c1d95";
          ctx.lineWidth = 2;
          const r = p.w / 2;
          ctx.beginPath();
          ctx.arc(r, r, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          ctx.strokeStyle = "#f9f5ff";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(r, r);
          ctx.lineTo(r, r - 7);
          ctx.moveTo(r, r);
          ctx.lineTo(r + 6, r + 3);
          ctx.stroke();
        }

        ctx.restore();
      });

      // Ground line
      ctx.strokeStyle = "rgba(148, 163, 184, 0.7)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, GROUND_Y + 1);
      ctx.lineTo(WORLD_WIDTH, GROUND_Y + 1);
      ctx.stroke();

      // Notita de saltos al lado del jugador
      const jumpsLeft = Math.max(0, maxJumps - player.jumpsUsed);
      const noteX = player.x + player.w + 10;
      const noteY = player.y + 2;
      const noteW = 78;
      const noteH = 24;
      ctx.fillStyle = "rgba(15, 23, 42, 0.9)";
      ctx.fillRect(noteX, noteY, noteW, noteH);
      ctx.strokeStyle = "rgba(148, 163, 184, 0.9)";
      ctx.lineWidth = 1.5;
      ctx.strokeRect(noteX, noteY, noteW, noteH);
      ctx.fillStyle = "#e5f0ff";
      ctx.font = "10px system-ui";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.fillText("JUMPS", noteX + 6, noteY + 3);
      ctx.fillStyle = "#22c55e";
      ctx.fillText("LEFT: " + jumpsLeft, noteX + 6, noteY + 13);
    }

    // LOOP

    function loop(timestamp) {
      if (!isRunning) return;
      if (!lastTime) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      updateGame(dt);
      drawGame();

      if (isRunning) {
        requestAnimationFrame(loop);
      }
    }

    function startGame() {
      resetGameState();
      showView("game");
      isRunning = true;
      lastTime = 0;
      playMusic(); // música solo en partida
      requestAnimationFrame(loop);
    }

    function endGame() {
      isRunning = false;
      stopMusic(); // detener música al perder
      const score = liveScore();
      if (score > bestScore) bestScore = score;

      finalScoreText.textContent = score;
      bestScoreText.textContent = bestScore;
      destroyedText.textContent = obstaclesDestroyed;
      timeText.textContent = `${Math.floor(survivalTime)} s`;

      showView("gameOver");
    }

    // INPUT

    function tryJump() {
      if (!isRunning) return;
      if (player.jumpsUsed < maxJumps) {
        player.vy = -JUMP_FORCE;
        player.jumpsUsed++;
        playBeep("jump");
      }
    }

    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        if (currentView === "game" && isRunning) {
          tryJump();
        } else if (currentView === "gameOver" && !isRunning) {
          startGame();
        }
      } else if (e.key === "Shift" || e.code === "ShiftLeft" || e.code === "ShiftRight") {
        // Solicitar drop en este frame si estamos en el juego
        if (currentView === "game" && isRunning) {
          dropRequested = true;
        }
      }
    });

    function addTapJump(target) {
      target.addEventListener(
        "touchstart",
        (e) => {
          e.preventDefault();
          if (currentView === "game" && isRunning) {
            tryJump();
          } else if (currentView === "gameOver" && !isRunning) {
            startGame();
          }
        },
        { passive: false }
      );
    }

    addTapJump(canvas);
    addTapJump(document.body);

    // BUTTONS

    document.getElementById("btnPlay").addEventListener("click", () => {
      startGame();
    });

    document
      .getElementById("btnInstructions")
      .addEventListener("click", () => {
        stopMusic(); // aseguramos no suena en instrucciones
        showView("instructions");
      });

    document.getElementById("btnBackMenu").addEventListener("click", () => {
      stopMusic();
      showView("menu");
    });

    document
      .getElementById("btnPlayFromInstructions")
      .addEventListener("click", () => {
        startGame();
      });

    document.getElementById("btnRestart").addEventListener("click", () => {
      startGame();
    });

    document.getElementById("btnGoMenu").addEventListener("click", () => {
      stopMusic();
      showView("menu");
    });
  </script>
</body>
</html>
