<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Andromadorian Runner – Neon Skies</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg-main: radial-gradient(circle at top, #f5f3ff 0, #0b1120 60%);
      --panel: rgba(15, 23, 42, 0.98);
      --accent: #06b6d4;
      --accent-2: #6366f1;
      --accent-3: #f97316;
      --danger: #ef4444;
      --text: #e5e7eb;
      --muted: #9ca3af;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--bg-main);
      color: var(--text);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .app {
      width: 100%;
      max-width: 1400px;
      padding: 12px;
    }

    .view {
      display: none;
      background: radial-gradient(circle at top, #020617 0, #020617 55%, #020617 100%);
      border-radius: 22px;
      box-shadow: 0 22px 60px rgba(0, 0, 0, 0.95);
      padding: 18px 14px 16px;
      min-height: min(96vh, 780px);
      position: relative;
      overflow: hidden;
    }

    .view.active {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .view-header {
      text-align: center;
      margin-bottom: 18px;
    }

    .view-header h1 {
      font-size: 2.1rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: #f97316;
      text-shadow:
        0 0 10px rgba(249, 115, 22, 0.9),
        0 0 28px rgba(56, 189, 248, 0.6);
      margin-bottom: 4px;
    }

    .view-header p {
      font-size: 0.9rem;
      color: var(--muted);
    }

    /* CARD / MENU */

    .card {
      background: radial-gradient(circle at top, #0b1120 0, #020617 52%, #020617 100%);
      border-radius: 20px;
      padding: 18px 16px 14px;
      max-width: 520px;
      width: 100%;
      border: 1px solid rgba(148, 163, 184, 0.6);
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.9);
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: "";
      position: absolute;
      inset: -140px;
      background:
        radial-gradient(circle at top left, rgba(56, 189, 248, 0.16), transparent 60%),
        radial-gradient(circle at bottom right, rgba(236, 72, 153, 0.16), transparent 60%);
      pointer-events: none;
      opacity: 0.9;
    }

    .card-inner {
      position: relative;
      z-index: 1;
    }

    .section {
      padding: 8px 0;
    }

    .section + .section {
      border-top: 1px dashed rgba(148, 163, 184, 0.4);
      margin-top: 9px;
    }

    .section-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--muted);
      margin-bottom: 7px;
    }

    .btn {
      border: none;
      border-radius: 999px;
      padding: 10px 16px;
      font-size: 0.98rem;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.07em;
      text-transform: uppercase;
      width: 100%;
      background: linear-gradient(135deg, #22c55e, #a3e635);
      color: #022c22;
      box-shadow: 0 10px 24px rgba(34, 197, 94, 0.65);
      transition:
        transform 0.12s ease,
        box-shadow 0.12s ease,
        filter 0.12s ease;
    }

    .btn:hover {
      transform: translateY(-1px);
      filter: brightness(1.05);
      box-shadow: 0 14px 30px rgba(34, 197, 94, 0.78);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow: 0 7px 18px rgba(34, 197, 94, 0.6);
    }

    .btn-ghost {
      background: transparent;
      color: var(--accent-2);
      border: 1px solid rgba(129, 140, 248, 0.9);
      box-shadow: none;
    }

    .btn-ghost:hover {
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.9);
      background: radial-gradient(circle, rgba(129, 140, 248, 0.16), transparent 70%);
    }

    .btn-row {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 4px;
    }

    .diff-toggle {
      display: flex;
      gap: 6px;
      padding: 3px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid rgba(148, 163, 184, 0.6);
    }

    .diff-btn {
      flex: 1;
      border-radius: 999px;
      border: none;
      font-size: 0.75rem;
      padding: 5px 0;
      cursor: pointer;
      background: transparent;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-weight: 600;
      transition:
        background 0.15s ease,
        color 0.15s ease,
        box-shadow 0.15s ease;
    }

    .diff-btn.active {
      background: linear-gradient(135deg, #6366f1, #22c55e);
      color: #020617;
      box-shadow: 0 4px 12px rgba(129, 140, 248, 0.75);
    }

    .skin-grid {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .skin-option {
      border-radius: 12px;
      padding: 4px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: rgba(15, 23, 42, 0.9);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 3px;
      min-width: 70px;
      transition:
        border-color 0.15s ease,
        box-shadow 0.15s ease,
        transform 0.12s ease,
        background 0.15s ease;
    }

    .skin-option:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 22px rgba(0, 0, 0, 0.7);
    }

    .skin-option.active {
      border-color: #f97316;
      box-shadow: 0 0 16px rgba(249, 115, 22, 0.7);
      background: radial-gradient(circle, rgba(249, 115, 22, 0.16), rgba(15, 23, 42, 0.95));
    }

    .skin-preview {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      overflow: hidden;
      background: #020617;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .skin-preview img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .skin-label {
      font-size: 0.72rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .hint {
      font-size: 0.75rem;
      color: var(--muted);
      margin-top: 6px;
    }

    .kbd {
      display: inline-block;
      padding: 1px 5px;
      border-radius: 4px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.8);
      font-size: 0.75rem;
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo,
        Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    /* INSTRUCTIONS */

    #viewInstructions .card {
      max-width: 760px;
    }

    .instructions-grid {
      display: grid;
      gap: 10px;
      font-size: 0.9rem;
    }

    @media (min-width: 820px) {
      .instructions-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    .instructions-grid h3 {
      font-size: 0.9rem;
      margin-bottom: 3px;
      color: var(--accent-2);
    }

    ul {
      list-style: disc;
      padding-left: 16px;
      color: var(--muted);
    }

    ul li + li {
      margin-top: 3px;
    }

    .footer-row {
      margin-top: 12px;
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      flex-wrap: wrap;
    }

    /* GAME */

    #viewGame {
      align-items: stretch;
      justify-content: flex-start;
      padding: 12px 10px 14px;
      gap: 8px;
    }

    .hud-bar {
      width: 100%;
      max-width: 1320px;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      padding: 6px 9px;
      border-radius: 999px;
      background: radial-gradient(circle at top, rgba(15, 23, 42, 0.96), #020617);
      border: 1px solid rgba(148, 163, 184, 0.5);
    }

    .hud-left,
    .hud-right {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 6px;
    }

    .pill {
      border-radius: 999px;
      padding: 3px 8px;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      background: rgba(15, 23, 42, 0.9);
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .pill strong {
      color: var(--accent-2);
    }

    .pill-score {
      background: linear-gradient(135deg, #22c55e, #a3e635);
      color: #022c22;
      box-shadow: 0 0 18px rgba(34, 197, 94, 0.75);
    }

    .pill-score strong {
      color: #022c22;
    }

    .indicator-dot {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: #22c55e;
      box-shadow: 0 0 8px rgba(34, 197, 94, 0.8);
    }

    #gameCanvas {
      margin: 8px auto 0;
      display: block;
      background: #020617;
      width: 100%;
      max-width: 1320px;
      border-radius: 20px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      box-shadow: 0 22px 52px rgba(0, 0, 0, 0.95);
    }

    .touch-hint {
      margin: 6px auto 0;
      text-align: center;
      font-size: 0.78rem;
      color: var(--muted);
    }

    /* GAME OVER */

    #viewGameOver .card {
      max-width: 440px;
      background: radial-gradient(circle at top, #0f172a 0, #020617 70%);
    }

    .go-title {
      font-size: 1.4rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--danger);
      text-shadow: 0 0 12px rgba(239, 68, 68, 0.9);
      margin-bottom: 2px;
      text-align: center;
    }

    .go-sub {
      font-size: 0.86rem;
      color: var(--muted);
      text-align: center;
      margin-bottom: 10px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.86rem;
      padding: 2px 0;
      color: var(--muted);
    }

    .stat-row strong {
      color: var(--accent-2);
    }

    .go-tip {
      font-size: 0.76rem;
      text-align: center;
      margin-top: 8px;
      color: var(--muted);
    }

    @media (max-width: 840px) {
      .view {
        padding: 14px 10px 10px;
        min-height: 90vh;
      }
      .view-header h1 {
        font-size: 1.6rem;
      }
      .hud-bar {
        flex-direction: column;
        align-items: flex-start;
        border-radius: 16px;
      }
      .hud-right {
        justify-content: flex-end;
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- MAIN MENU -->
    <section id="viewMenu" class="view active">
      <div class="view-header">
        <h1>ANDROMADORIAN RUNNER</h1>
        <p>Triple-jump skies, sliding islands and swappable neon heads.</p>
      </div>

      <div class="card">
        <div class="card-inner">
          <div class="section">
            <div class="section-title">Difficulty</div>
            <div class="diff-toggle" id="diffToggle">
              <button class="diff-btn" data-mode="easy">Easy</button>
              <button class="diff-btn active" data-mode="normal">Normal</button>
              <button class="diff-btn" data-mode="hard">Hard</button>
            </div>
            <p class="hint">
              Higher difficulty = faster world and denser obstacle waves (which ramp over time).
            </p>
          </div>

          <div class="section">
            <div class="section-title">Skin (Head)</div>
            <div class="skin-grid" id="skinGrid">
              <div class="skin-option active" data-skin="face1.png">
                <div class="skin-preview">
                  <img src="assets/faces/face1.png" alt="Skin 1" />
                </div>
                <div class="skin-label">Skin 1</div>
              </div>
              <div class="skin-option" data-skin="face2.png">
                <div class="skin-preview">
                  <img src="assets/faces/face2.png" alt="Skin 2" />
                </div>
                <div class="skin-label">Skin 2</div>
              </div>
              <div class="skin-option" data-skin="face3.png">
                <div class="skin-preview">
                  <img src="assets/faces/face3.png" alt="Skin 3" />
                </div>
                <div class="skin-label">Skin 3</div>
              </div>
            </div>
            <p class="hint">
              Place PNGs in <span class="kbd">/assets/faces/face1.png</span>, <span class="kbd">face2.png</span>, etc.
            </p>
          </div>

          <div class="section">
            <div class="section-title">Play</div>
            <div class="btn-row">
              <button id="btnPlay" class="btn">Start Run</button>
              <button id="btnInstructions" class="btn btn-ghost">How to Play</button>
            </div>
          </div>

          <div class="section">
            <div class="section-title">Controls</div>
            <p class="hint">
              Desktop: <span class="kbd">Space</span> = jump (up to 3 jumps), 
              <span class="kbd">Shift</span> = drop through platform.<br />
              Mobile: tap on the game area to jump.
            </p>
          </div>
        </div>
      </div>
    </section>

    <!-- INSTRUCTIONS -->
    <section id="viewInstructions" class="view">
      <div class="view-header">
        <h1>How to Play</h1>
        <p>Jump between floating lanes, stomp hazards, collect orbs and keep your head intact.</p>
      </div>

      <div class="card">
        <div class="card-inner">
          <div class="instructions-grid">
            <div>
              <h3>Movement</h3>
              <ul>
                <li>Your runner auto-moves to the right.</li>
                <li>Press <span class="kbd">Space</span> or tap to jump.</li>
                <li>You can chain up to <strong>3 jumps</strong> mid-air by default.</li>
                <li>Landing on ground or platforms restores all jumps.</li>
                <li>Stomping an obstacle from above restores jumps and destroys it.</li>
                <li>Press <span class="kbd">Shift</span> while on a platform to drop through it.</li>
                <li>There's a ceiling: you cannot go above it, but you won't lose by touching it.</li>
              </ul>
            </div>

            <div>
              <h3>Obstacles</h3>
              <ul>
                <li>Neon shards and blocks appear on the ground, mid-air and near the ceiling.</li>
                <li>Most hazards sway horizontally for trickier timing.</li>
                <li>Touching a hazard from the side or below = instant defeat (unless shielded).</li>
                <li>Spawn frequency increases over time on every difficulty.</li>
              </ul>
            </div>

            <div>
              <h3>Power-ups</h3>
              <ul>
                <li><strong>Shield</strong>: survives one hit and turns it into a smash.</li>
                <li><strong>Jump Boost</strong>: temporarily increases max jumps.</li>
                <li><strong>Score Burst</strong>: instantly adds bonus score.</li>
                <li><strong>Slow Time</strong>: slows world speed for a while.</li>
                <li>Run through power-ups to grab them.</li>
              </ul>
            </div>

            <div>
              <h3>Score</h3>
              <ul>
                <li><strong>+1</strong> point every second you survive.</li>
                <li><strong>+1</strong> point per obstacle destroyed.</li>
                <li>Some power-ups add extra score.</li>
                <li>Live score is shown in the HUD at the top.</li>
              </ul>
            </div>

            <div>
              <h3>Platforms &amp; Levels</h3>
              <ul>
                <li>Three vertical lanes of floating platforms, each with gaps.</li>
                <li>Use upper floors to route around dense waves of hazards.</li>
                <li>World themes shift as time passes (sky, colors and silhouettes change).</li>
              </ul>
            </div>

            <div>
              <h3>Difficulty &amp; Skins</h3>
              <ul>
                <li>Select Easy / Normal / Hard for speed + spawn tuning.</li>
                <li>Choose your head skin in the main menu. It is drawn as a large PNG sprite.</li>
                <li>Music plays only during the actual run, never in menus or after defeat.</li>
              </ul>
            </div>
          </div>

          <div class="footer-row">
            <button id="btnBackMenu" class="btn btn-ghost">Back to Menu</button>
            <button id="btnPlayFromInstructions" class="btn">Start Run</button>
          </div>
        </div>
      </div>
    </section>

    <!-- GAME -->
    <section id="viewGame" class="view">
      <div class="hud-bar">
        <div class="hud-left">
          <div class="pill pill-score">
            SCORE:<strong id="scoreText">0</strong>
          </div>
          <div class="pill">
            LEVEL:<strong id="levelText">1 – Dawn City</strong>
          </div>
          <div class="pill">
            MODE:<strong id="modeText">Normal</strong>
          </div>
          <div class="pill">
            SHIELD:<strong id="shieldText">Off</strong>
          </div>
          <div class="pill">
            JUMP BOOST:<strong id="jumpBoostText">-</strong>
          </div>
          <div class="pill">
            BONUS:<strong id="bonusText">0</strong>
          </div>
          <div class="pill">
            SLOW:<strong id="slowText">Off</strong>
          </div>
        </div>
        <div class="hud-right">
          <span class="indicator-dot"></span>
          <span style="font-size: 0.75rem; color: var(--muted); text-transform: uppercase; letter-spacing: 0.12em;">
            RUNNING
          </span>
        </div>
      </div>

      <!-- Canvas ampliado -->
      <canvas id="gameCanvas" width="1280" height="640"></canvas>
      <p class="touch-hint">
        Space / tap = jump (up to 3 default jumps). Shift = drop down from platforms.<br />
        Stomp from above to crush hazards and refill jumps.
      </p>
    </section>

    <!-- GAME OVER -->
    <section id="viewGameOver" class="view">
      <div class="card">
        <div class="card-inner">
          <div class="go-title">RUN ENDED</div>
          <p class="go-sub">
            Press <strong>Restart</strong> or hit <span class="kbd">Space</span> to launch a new run.
          </p>

          <div class="stat-row">
            <span>Final Score</span>
            <strong id="finalScoreText">0</strong>
          </div>
          <div class="stat-row">
            <span>Best (session)</span>
            <strong id="bestScoreText">0</strong>
          </div>
          <div class="stat-row">
            <span>Obstacles Destroyed</span>
            <strong id="destroyedText">0</strong>
          </div>
          <div class="stat-row">
            <span>Time Survived</span>
            <strong id="timeText">0 s</strong>
          </div>

          <div class="btn-row" style="margin-top: 10px;">
            <button id="btnRestart" class="btn">Restart</button>
            <button id="btnGoMenu" class="btn btn-ghost">Main Menu</button>
          </div>

          <p class="go-tip">
            Tip: Pick a skin you like, ride upper lanes, drop down with Shift and chain stomps to keep your triple jump alive.
          </p>
        </div>
      </div>
    </section>
  </div>

  <script>
    // AUDIO:
    // Coloca un archivo MP3 de música de partida en:
    // /assets/audio/game-start.mp3
    // Se reproducirá en loop SOLO mientras la partida esté en curso.
    const bgMusic = new Audio("assets/audio/game-start.mp3");
    bgMusic.loop = true;

    let audioCtx = null;

    function ensureAudioContext() {
      if (!audioCtx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (!AC) return;
        audioCtx = new AC();
      }
      if (audioCtx && audioCtx.state === "suspended") {
        audioCtx.resume().catch(() => {});
      }
    }

    function playMusic() {
      try {
        ensureAudioContext();
        bgMusic.currentTime = 0;
        bgMusic.play().catch(() => {});
      } catch (_) {}
    }

    function stopMusic() {
      try {
        bgMusic.pause();
      } catch (_) {}
    }

    function playBeep(type) {
      try {
        ensureAudioContext();
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        let freq = 440;
        let dur = 0.08;

        switch (type) {
          case "jump":
            freq = 880;
            dur = 0.06;
            break;
          case "stomp":
            freq = 240;
            dur = 0.11;
            break;
          case "hit":
            freq = 130;
            dur = 0.16;
            break;
          case "power":
            freq = 1020;
            dur = 0.12;
            break;
        }

        osc.type = "sine";
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.24, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(
          0.001,
          audioCtx.currentTime + dur
        );
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + dur);
      } catch (_) {}
    }

    // VIEWS

    const views = {
      menu: document.getElementById("viewMenu"),
      instructions: document.getElementById("viewInstructions"),
      game: document.getElementById("viewGame"),
      gameOver: document.getElementById("viewGameOver"),
    };
    let currentView = "menu";

    function showView(id) {
      Object.values(views).forEach((v) => v.classList.remove("active"));
      views[id].classList.add("active");
      currentView = id;
    }

    // DIFFICULTY

    const diffToggle = document.getElementById("diffToggle");
    const diffButtons = diffToggle.querySelectorAll(".diff-btn");
    const modeText = document.getElementById("modeText");

    let difficulty = "normal";

    const difficultySettings = {
      easy: { speed: 280, minSpawn: 0.5, maxSpawn: 0.75 },
      normal: { speed: 340, minSpawn: 0.35, maxSpawn: 0.55 },
      hard: { speed: 400, minSpawn: 0.22, maxSpawn: 0.42 },
    };

    diffButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        diffButtons.forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        difficulty = btn.dataset.mode;
        modeText.textContent =
          difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
      });
    });

    // SKINS

    const skinGrid = document.getElementById("skinGrid");
    const skinOptions = skinGrid.querySelectorAll(".skin-option");
    let selectedSkinFile = "face1.png";

    skinOptions.forEach((opt) => {
      opt.addEventListener("click", () => {
        skinOptions.forEach((o) => o.classList.remove("active"));
        opt.classList.add("active");
        selectedSkinFile = opt.getAttribute("data-skin") || "face1.png";
        faceImg.src = "assets/faces/" + selectedSkinFile;
      });
    });

    // GAME CONSTANTS & STATE

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const WORLD_WIDTH = canvas.width;
    const WORLD_HEIGHT = canvas.height;

    // Menos piso, más espacio superior
    const GROUND_HEIGHT = 110;
    const GROUND_Y = WORLD_HEIGHT - GROUND_HEIGHT;
    const CEILING_Y = 40;

    const GRAVITY = 2200;
    const JUMP_FORCE = 800;
    const BASE_MAX_JUMPS = 3;
    const LEVEL_DURATION = 26;

    const PLATFORM_LENGTH = 300;
    const PLATFORM_GAP = 200;
    const PLATFORM_BANDS = 3;

    // HUD refs
    const scoreText = document.getElementById("scoreText");
    const levelText = document.getElementById("levelText");
    const shieldText = document.getElementById("shieldText");
    const jumpBoostText = document.getElementById("jumpBoostText");
    const bonusText = document.getElementById("bonusText");
    const slowText = document.getElementById("slowText");

    const finalScoreText = document.getElementById("finalScoreText");
    const bestScoreText = document.getElementById("bestScoreText");
    const destroyedText = document.getElementById("destroyedText");
    const timeText = document.getElementById("timeText");

    let isRunning = false;
    let lastTime = 0;

    let player;
    let obstacles = [];
    let powerups = [];
    let platforms = [];

    let survivalTime = 0;
    let obstaclesDestroyed = 0;
    let bonusScore = 0;
    let bestScore = 0;

    let obstacleTimer = 0;
    let nextObstacleSpawn = 1;

    let powerTimer = 0;
    let nextPowerSpawn = 8;

    let currentLevel = 0;

    let maxJumps = BASE_MAX_JUMPS;
    let shieldActive = false;
    let jumpBoostTime = 0;
    let slowTime = 0;
    let speedFactor = 1;

    let runAnimTime = 0;

    // Drop-through control
    let dropRequested = false;

    // Runner head image (big)
    const faceImg = new Image();
    faceImg.src = "assets/faces/" + selectedSkinFile;

    const themes = [
      {
        name: "Dawn City",
        skyTop: "#0ea5e9",
        skyBottom: "#020617",
        glow: "#fde047",
        far: "#0f172a",
        mid: "#1e293b",
        ground: "#22c55e",
      },
      {
        name: "Solar Desert",
        skyTop: "#fb923c",
        skyBottom: "#7c2d12",
        glow: "#facc15",
        far: "#92400e",
        mid: "#b45309",
        ground: "#facc15",
      },
      {
        name: "Night Peaks",
        skyTop: "#1e293b",
        skyBottom: "#020617",
        glow: "#a855f7",
        far: "#020617",
        mid: "#1f2937",
        ground: "#22c55e",
      },
    ];

    let parallaxLayers = [];

    function applyTheme() {
      const theme = themes[currentLevel % themes.length];

      parallaxLayers = [
        {
          color: theme.far,
          y: WORLD_HEIGHT - 380,
          h: 260,
          speedFactor: 0.2,
          offset: 0,
        },
        {
          color: theme.mid,
          y: WORLD_HEIGHT - 290,
          h: 230,
          speedFactor: 0.45,
          offset: 0,
        },
        {
          color: theme.ground,
          y: GROUND_Y,
          h: GROUND_HEIGHT + 60,
          speedFactor: 1,
          offset: 0,
        },
      ];

      levelText.textContent = `${currentLevel + 1} – ${theme.name}`;
    }

    function initPlatforms() {
      platforms = [];

      const bands = [
        { y: GROUND_Y - 130, offset: 120 },
        { y: GROUND_Y - 250, offset: 350 },
        { y: GROUND_Y - 370, offset: 610 },
      ];

      bands.forEach((band, index) => {
        for (let i = 0; i < 3; i++) {
          platforms.push({
            x: band.offset + i * (PLATFORM_LENGTH + PLATFORM_GAP),
            y: band.y,
            w: PLATFORM_LENGTH,
            h: 20,
            band: index,
          });
        }
      });
    }

    function rand(min, max) {
      return min + Math.random() * (max - min);
    }

    function obstacleSpawnWindow() {
      const cfg = difficultySettings[difficulty];
      const progress = Math.min(1, survivalTime / 60);
      const factor = 1 - 0.65 * progress;
      return {
        min: cfg.minSpawn * factor,
        max: cfg.maxSpawn * factor,
      };
    }

    function resetGameState() {
      const theme = themes[0];
      parallaxLayers = [
        {
          color: theme.far,
          y: WORLD_HEIGHT - 380,
          h: 260,
          speedFactor: 0.2,
          offset: 0,
        },
        {
          color: theme.mid,
          y: WORLD_HEIGHT - 290,
          h: 230,
          speedFactor: 0.45,
          offset: 0,
        },
        {
          color: theme.ground,
          y: GROUND_Y,
          h: GROUND_HEIGHT + 60,
          speedFactor: 1,
          offset: 0,
        },
      ];

      // Runner: solo piernitas + cabeza grande
      player = {
        w: 34,
        h: 56,                       // un poco más alto para incluir cabeza y piernas
        x: WORLD_WIDTH * 0.16,
        y: GROUND_Y - 56,
        vy: 0,
        jumpsUsed: 0,
      };

      initPlatforms();

      obstacles = [];
      powerups = [];

      survivalTime = 0;
      obstaclesDestroyed = 0;
      bonusScore = 0;

      obstacleTimer = 0;
      powerTimer = 0;
      const windowSpawn = obstacleSpawnWindow();
      nextObstacleSpawn = rand(windowSpawn.min, windowSpawn.max);
      nextPowerSpawn = rand(6, 11);

      currentLevel = 0;
      maxJumps = BASE_MAX_JUMPS;
      shieldActive = false;
      jumpBoostTime = 0;
      slowTime = 0;
      speedFactor = 1;
      applyTheme();
      updateScoreHUD();
      updatePowerHUD();
      runAnimTime = 0;
      dropRequested = false;

      // aplicar skin seleccionada
      faceImg.src = "assets/faces/" + selectedSkinFile;
    }

    function spawnObstacle() {
      const typeRoll = Math.random();

      // un poco más pequeños
      let w, h;
      if (typeRoll < 0.4) {
        w = 30;
        h = 36;
      } else if (typeRoll < 0.75) {
        w = 38;
        h = 52;
      } else {
        w = 48;
        h = 28;
      }

      const verticalRoll = Math.random();
      let y;
      let vType;
      if (verticalRoll < 0.45) {
        y = GROUND_Y - h;
        vType = "ground";
      } else if (verticalRoll < 0.8) {
        const minY = GROUND_Y - h - 240;
        const maxY = GROUND_Y - h - 110;
        y = rand(Math.max(70, minY), Math.max(100, maxY));
        vType = "mid";
      } else {
        y = rand(50, 180);
        vType = "ceiling";
      }

      let shape = "box";
      const shapeRoll = Math.random();
      if (shapeRoll < 0.5) shape = "box";
      else if (shapeRoll < 0.8) shape = "circle";
      else shape = "spike";

      // Movimiento horizontal más marcado
      let moveType = "static";
      let amplitude = 0;
      let moveSpeed = 0;
      let phase = 0;
      const moveRoll = Math.random();
      if (moveRoll < 0.55) {
        moveType = "hmove";
        amplitude = rand(28, 60);
        moveSpeed = rand(5, 10);
        phase = Math.random() * Math.PI * 2;
      }

      const baseX = WORLD_WIDTH + w;

      obstacles.push({
        baseX,
        x: baseX,
        y,
        w,
        h,
        shape,
        vType,
        moveType,
        amplitude,
        moveSpeed,
        phase,
        offsetX: 0,
      });

      const windowSpawn = obstacleSpawnWindow();
      nextObstacleSpawn = rand(windowSpawn.min, windowSpawn.max);
    }

    function spawnPowerup() {
      const kinds = ["shield", "jump", "score", "slow"];
      const kind = kinds[Math.floor(Math.random() * kinds.length)];

      const size = 34;
      const roll = Math.random();
      let y;
      if (roll < 0.33) {
        y = GROUND_Y - size - 70;
      } else if (roll < 0.66) {
        y = GROUND_Y - size - 180;
      } else {
        y = rand(110, GROUND_Y - size - 200);
      }

      powerups.push({
        x: WORLD_WIDTH + 100,
        y,
        w: size,
        h: size,
        kind,
      });

      const progress = Math.min(1, survivalTime / 80);
      const factor = 1 - 0.4 * progress;
      nextPowerSpawn = rand(7 * factor, 13 * factor);
    }

    function rectsOverlap(a, b) {
      return !(
        a.x + a.w < b.x ||
        a.x > b.x + b.w ||
        a.y + a.h < b.y ||
        a.y > b.y + b.h
      );
    }

    function liveScore() {
      return Math.floor(survivalTime) + obstaclesDestroyed + bonusScore;
    }

    function updateScoreHUD() {
      scoreText.textContent = liveScore();
    }

    function updatePowerHUD() {
      shieldText.textContent = shieldActive ? "On" : "Off";
      jumpBoostText.textContent =
        jumpBoostTime > 0 ? Math.ceil(jumpBoostTime) + "s" : "-";
      bonusText.textContent = bonusScore;
      slowText.textContent = slowTime > 0 ? "On" : "Off";
    }

    function applyPower(kind) {
      if (kind === "shield") {
        shieldActive = true;
      } else if (kind === "jump") {
        jumpBoostTime = 10;
      } else if (kind === "score") {
        bonusScore += 10;
      } else if (kind === "slow") {
        slowTime = 6;
        speedFactor = 0.6;
      }
      updatePowerHUD();
    }

    function updatePlatforms(dt, gameSpeed) {
      for (let band = 0; band < PLATFORM_BANDS; band++) {
        let maxX = -Infinity;
        platforms.forEach((p) => {
          if (p.band === band && p.x > maxX) {
            maxX = p.x;
          }
        });

        platforms.forEach((p) => {
          if (p.band !== band) return;
          p.x -= gameSpeed * dt;
          if (p.x + p.w < -150) {
            p.x = maxX + PLATFORM_LENGTH + PLATFORM_GAP;
            maxX = p.x;
          }
        });
      }
    }

    function updateGame(dt) {
      if (!isRunning) return;

      if (jumpBoostTime > 0) {
        jumpBoostTime -= dt;
        if (jumpBoostTime < 0) jumpBoostTime = 0;
      }
      if (slowTime > 0) {
        slowTime -= dt;
        if (slowTime <= 0) {
          slowTime = 0;
          speedFactor = 1;
        }
      }
      maxJumps = jumpBoostTime > 0 ? 5 : BASE_MAX_JUMPS;
      updatePowerHUD();

      const cfg = difficultySettings[difficulty];
      const worldSpeed = cfg.speed * speedFactor;

      // Tiempo & niveles
      survivalTime += dt;
      const targetLevel = Math.floor(survivalTime / LEVEL_DURATION);
      if (targetLevel !== currentLevel) {
        currentLevel = targetLevel;
        applyTheme();
      }

      // Física del jugador
      const prevBottom = player.y + player.h;

      player.vy += GRAVITY * dt;
      let newY = player.y + player.vy * dt;
      let newBottom = newY + player.h;

      // Techo: no se puede pasar, pero no pierde
      if (newY < CEILING_Y) {
        newY = CEILING_Y;
        newBottom = newY + player.h;
        if (player.vy < 0) player.vy = 0;
      }

      let onPlatform = false;

      // Plataformas con drop
      for (let i = 0; i < platforms.length; i++) {
        const pf = platforms[i];
        const top = pf.y;
        const overlapX =
          player.x + player.w > pf.x &&
          player.x < pf.x + pf.w;

        if (
          dropRequested &&
          overlapX &&
          prevBottom >= top - 2 &&
          prevBottom <= top + 6
        ) {
          // saltar esta plataforma para caer
          continue;
        }

        if (
          overlapX &&
          prevBottom <= top &&
          newBottom >= top
        ) {
          newY = top - player.h;
          newBottom = newY + player.h;
          player.vy = 0;
          player.jumpsUsed = 0;
          onPlatform = true;
          break;
        }
      }

      // Suelo
      if (!onPlatform && newBottom >= GROUND_Y) {
        newY = GROUND_Y - player.h;
        newBottom = newY + player.h;
        player.vy = 0;
        player.jumpsUsed = 0;
      }

      player.y = newY;

      // Plataformas movimiento
      updatePlatforms(dt, worldSpeed);

      // Obstáculos
      obstacleTimer += dt;
      if (obstacleTimer >= nextObstacleSpawn) {
        spawnObstacle();
        obstacleTimer = 0;
      }

      const playerRect = {
        x: player.x,
        y: player.y,
        w: player.w,
        h: player.h,
      };

      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        o.baseX -= worldSpeed * dt;
        if (o.moveType === "hmove") {
          o.phase += o.moveSpeed * dt;
          o.offsetX = Math.sin(o.phase) * o.amplitude;
        } else {
          o.offsetX = 0;
        }
        o.x = o.baseX + o.offsetX;

        if (o.baseX + o.w < -100) {
          obstacles.splice(i, 1);
          continue;
        }
      }

      // Colisiones con obstáculos
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        if (!rectsOverlap(playerRect, o)) continue;

        const wasAbove = prevBottom <= o.y + 8;
        if (wasAbove && player.vy > 0) {
          obstacles.splice(i, 1);
          obstaclesDestroyed++;
          player.vy = -JUMP_FORCE * 0.7;
          player.jumpsUsed = 0;
          playBeep("stomp");
        } else if (shieldActive) {
          shieldActive = false;
          obstacles.splice(i, 1);
          obstaclesDestroyed++;
          playBeep("stomp");
          updatePowerHUD();
        } else {
          playBeep("hit");
          endGame();
          return;
        }
      }

      // Power-ups
      powerTimer += dt;
      if (powerTimer >= nextPowerSpawn) {
        spawnPowerup();
        powerTimer = 0;
      }

      for (let i = powerups.length - 1; i >= 0; i--) {
        const p = powerups[i];
        p.x -= worldSpeed * dt * 0.85;

        if (p.x + p.w < -100) {
          powerups.splice(i, 1);
          continue;
        }

        if (rectsOverlap(playerRect, p)) {
          applyPower(p.kind);
          playBeep("power");
          powerups.splice(i, 1);
        }
      }

      // Parallax
      parallaxLayers.forEach((layer) => {
        layer.offset -= worldSpeed * layer.speedFactor * dt;
        if (layer.offset <= -WORLD_WIDTH) {
          layer.offset += WORLD_WIDTH;
        }
      });

      runAnimTime += dt;
      updateScoreHUD();
      dropRequested = false;
    }

    // DIBUJO

    function drawSky(theme) {
      const gradient = ctx.createLinearGradient(
        0,
        0,
        0,
        WORLD_HEIGHT
      );
      gradient.addColorStop(0, theme.skyTop);
      gradient.addColorStop(0.5, theme.skyBottom);
      gradient.addColorStop(1, "#020617");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

      // Nubes
      ctx.save();
      ctx.fillStyle = "rgba(248, 250, 252, 0.85)";
      for (let i = 0; i < 6; i++) {
        const baseX = (i * 260 - (survivalTime * 40) % 260) - 100;
        const y = 60 + (i % 3) * 40;
        ctx.beginPath();
        ctx.ellipse(baseX, y, 90, 26, 0, 0, Math.PI * 2);
        ctx.ellipse(baseX + 52, y + 4, 60, 20, 0, 0, Math.PI * 2);
        ctx.ellipse(baseX - 52, y + 4, 60, 20, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();

      // Disco solar / lunar
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = theme.glow;
      ctx.beginPath();
      ctx.arc(WORLD_WIDTH * 0.1, 90, 40, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Línea techo
      ctx.save();
      ctx.strokeStyle = "rgba(148, 163, 184, 0.4)";
      ctx.setLineDash([6, 6]);
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, CEILING_Y);
      ctx.lineTo(WORLD_WIDTH, CEILING_Y);
      ctx.stroke();
      ctx.restore();
    }

    function drawDecor(theme) {
      ctx.save();

      if (theme.name.includes("City")) {
        const baseY = WORLD_HEIGHT - 260;
        for (let i = 0; i < 14; i++) {
          const w = 70;
          const h = 100 + (i % 3) * 30;
          const x =
            (i * 110 - (survivalTime * 45) % 110) - 60;
          ctx.fillStyle = i % 2 === 0 ? theme.far : theme.mid;
          ctx.fillRect(x, baseY + 140 - h, w, h);

          // Ventanas
          ctx.fillStyle = "rgba(250, 250, 210, 0.7)";
          for (let r = 0; r < 4; r++) {
            for (let c = 0; c < 2; c++) {
              if ((r + c + i) % 2 === 0) continue;
              const wx = x + 10 + c * 26;
              const wy = baseY + 134 - h + r * 18;
              ctx.fillRect(wx, wy, 10, 7);
            }
          }
        }
      } else if (theme.name.includes("Desert")) {
        const baseY = WORLD_HEIGHT - 260;
        ctx.fillStyle = theme.far;
        for (let i = 0; i < 4; i++) {
          const w = 280;
          const x =
            (i * 280 - (survivalTime * 36) % 280) - 100;
          ctx.beginPath();
          ctx.moveTo(x, baseY + 110);
          ctx.quadraticCurveTo(
            x + w / 2,
            baseY - 10,
            x + w,
            baseY + 110
          );
          ctx.lineTo(x + w, WORLD_HEIGHT);
          ctx.lineTo(x, WORLD_HEIGHT);
          ctx.closePath();
          ctx.fill();
        }
      } else {
        // Peaks
        const baseY = WORLD_HEIGHT - 270;
        ctx.fillStyle = theme.far;
        for (let i = 0; i < 5; i++) {
          const w = 240;
          const x =
            (i * 240 - (survivalTime * 30) % 240) - 90;
          ctx.beginPath();
          ctx.moveTo(x, baseY + 130);
          ctx.lineTo(x + w / 2, baseY - 20);
          ctx.lineTo(x + w, baseY + 130);
          ctx.closePath();
          ctx.fill();
        }
      }

      ctx.restore();
    }

    function drawGame() {
      const theme = themes[currentLevel % themes.length];

      drawSky(theme);
      drawDecor(theme);

      // Parallax layers
      parallaxLayers.forEach((layer) => {
        ctx.fillStyle = layer.color;
        const off = layer.offset;
        ctx.fillRect(off, layer.y, WORLD_WIDTH, layer.h);
        ctx.fillRect(off + WORLD_WIDTH, layer.y, WORLD_WIDTH, layer.h);
      });

      // Plataformas
      ctx.save();
      ctx.fillStyle = "rgba(15, 23, 42, 0.96)";
      ctx.strokeStyle = "rgba(148, 163, 184, 0.9)";
      ctx.lineWidth = 2;
      platforms.forEach((p) => {
        ctx.fillRect(p.x, p.y, p.w, p.h);
        ctx.strokeRect(p.x, p.y, p.w, p.h);
      });
      ctx.restore();

      // Runner: solo piernitas + cabeza grande
      ctx.save();
      ctx.translate(player.x, player.y);

      // Piernas (rápidas)
      const legBaseY = player.h - 6;
      const legBaseX = player.w / 2;
      const legLen = 14;
      const legSwing = Math.sin(runAnimTime * 90 + Math.PI) * 9;

      ctx.strokeStyle = "#22c55e";
      ctx.lineWidth = 4;
      ctx.lineCap = "round";

      // pierna derecha
      ctx.beginPath();
      ctx.moveTo(legBaseX + 3, legBaseY);
      ctx.lineTo(
        legBaseX + 3 + legSwing,
        legBaseY + legLen
      );
      ctx.stroke();

      // pierna izquierda
      ctx.beginPath();
      ctx.moveTo(legBaseX - 3, legBaseY);
      ctx.lineTo(
        legBaseX - 3 - legSwing,
        legBaseY + legLen
      );
      ctx.stroke();

      // Cabeza: PNG grande (sin cuerpo)
      const headSize = 34;
      const headX = (player.w - headSize) / 2;
      const headY = 4; // más arriba para dejar buen espacio para las piernas

      if (faceImg.complete && faceImg.naturalWidth) {
        ctx.drawImage(faceImg, headX, headY, headSize, headSize);
      } else {
        ctx.fillStyle = "#facc15";
        if (ctx.roundRect) {
          ctx.beginPath();
          ctx.roundRect(headX, headY, headSize, headSize, 6);
          ctx.fill();
        } else {
          ctx.fillRect(headX, headY, headSize, headSize);
        }
        ctx.fillStyle = "#0f172a";
        ctx.fillRect(headX + 4, headY + 8, headSize - 8, 7);
      }

      ctx.restore();

      // Obstáculos
      obstacles.forEach((o) => {
        ctx.save();
        ctx.translate(o.x, o.y);

        let color = "#f97373";
        if (o.vType === "mid") color = "#fbbf24";
        if (o.vType === "ceiling") color = "#22d3ee";

        ctx.fillStyle = color;
        ctx.strokeStyle = "rgba(15, 23, 42, 0.9)";
        ctx.lineWidth = 2;

        if (o.shape === "box") {
          ctx.beginPath();
          const radius = 6;
          if (ctx.roundRect) {
            ctx.roundRect(0, 0, o.w, o.h, radius);
            ctx.fill();
            ctx.stroke();
          } else {
            ctx.fillRect(0, 0, o.w, o.h);
            ctx.strokeRect(0, 0, o.w, o.h);
          }
        } else if (o.shape === "circle") {
          const r = Math.min(o.w, o.h) / 2;
          ctx.beginPath();
          ctx.arc(o.w / 2, o.h / 2, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        } else {
          ctx.beginPath();
          ctx.moveTo(0, o.h);
          ctx.lineTo(o.w / 2, 0);
          ctx.lineTo(o.w, o.h);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        }

        ctx.restore();
      });

      // Power-ups
      powerups.forEach((p) => {
        ctx.save();
        ctx.translate(p.x, p.y);

        if (p.kind === "shield") {
          ctx.fillStyle = "#22d3ee";
          ctx.strokeStyle = "#0f172a";
          ctx.lineWidth = 2;
          const r = p.w / 2;
          ctx.beginPath();
          ctx.arc(r, r, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = "#e5e7eb";
          ctx.font = "bold 14px system-ui";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("S", r, r);
        } else if (p.kind === "jump") {
          ctx.fillStyle = "#22c55e";
          ctx.strokeStyle = "#052e16";
          ctx.lineWidth = 2;
          const radius = 7;
          if (ctx.roundRect) {
            ctx.beginPath();
            ctx.roundRect(0, 0, p.w, p.h, radius);
            ctx.fill();
            ctx.stroke();
          } else {
            ctx.fillRect(0, 0, p.w, p.h);
            ctx.strokeRect(0, 0, p.w, p.h);
          }
          ctx.strokeStyle = "#e5f0ff";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(p.w / 2, p.h - 7);
          ctx.lineTo(p.w / 2, 9);
          ctx.moveTo(p.w / 2, 9);
          ctx.lineTo(p.w / 2 - 6, 15);
          ctx.moveTo(p.w / 2, 9);
          ctx.lineTo(p.w / 2 + 6, 15);
          ctx.stroke();
        } else if (p.kind === "score") {
          ctx.fillStyle = "#facc15";
          ctx.strokeStyle = "#451a03";
          ctx.lineWidth = 2;
          const cx = p.w / 2;
          const cy = p.h / 2;
          const outer = 14;
          const inner = 6;
          ctx.beginPath();
          for (let i = 0; i < 10; i++) {
            const angle = (i * Math.PI) / 5;
            const r = i % 2 === 0 ? outer : inner;
            const x = cx + Math.cos(angle) * r;
            const y = cy + Math.sin(angle) * r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        } else if (p.kind === "slow") {
          ctx.fillStyle = "#a855f7";
          ctx.strokeStyle = "#4c1d95";
          ctx.lineWidth = 2;
          const r = p.w / 2;
          ctx.beginPath();
          ctx.arc(r, r, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          ctx.strokeStyle = "#f9f5ff";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(r, r);
          ctx.lineTo(r, r - 8);
          ctx.moveTo(r, r);
          ctx.lineTo(r + 7, r + 4);
          ctx.stroke();
        }

        ctx.restore();
      });

      // Ground line
      ctx.strokeStyle = "rgba(148, 163, 184, 0.7)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, GROUND_Y + 1);
      ctx.lineTo(WORLD_WIDTH, GROUND_Y + 1);
      ctx.stroke();

      // Notita de saltos
      const jumpsLeft = Math.max(0, maxJumps - player.jumpsUsed);
      const noteX = player.x + player.w + 12;
      const noteY = player.y + 2;
      const noteW = 90;
      const noteH = 26;
      ctx.fillStyle = "rgba(15, 23, 42, 0.9)";
      ctx.fillRect(noteX, noteY, noteW, noteH);
      ctx.strokeStyle = "rgba(148, 163, 184, 0.9)";
      ctx.lineWidth = 1.5;
      ctx.strokeRect(noteX, noteY, noteW, noteH);
      ctx.fillStyle = "#e5f0ff";
      ctx.font = "10px system-ui";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.fillText("JUMPS", noteX + 6, noteY + 3);
      ctx.fillStyle = "#22c55e";
      ctx.fillText("LEFT: " + jumpsLeft, noteX + 6, noteY + 13);
    }

    // LOOP

    function loop(timestamp) {
      if (!isRunning) return;
      if (!lastTime) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      updateGame(dt);
      drawGame();

      if (isRunning) {
        requestAnimationFrame(loop);
      }
    }

    function startGame() {
      resetGameState();
      showView("game");
      isRunning = true;
      lastTime = 0;
      playMusic();
      requestAnimationFrame(loop);
    }

    function endGame() {
      isRunning = false;
      stopMusic();
      const score = liveScore();
      if (score > bestScore) bestScore = score;

      finalScoreText.textContent = score;
      bestScoreText.textContent = bestScore;
      destroyedText.textContent = obstaclesDestroyed;
      timeText.textContent = `${Math.floor(survivalTime)} s`;

      showView("gameOver");
    }

    // INPUT

    function tryJump() {
      if (!isRunning) return;
      if (player.jumpsUsed < maxJumps) {
        player.vy = -JUMP_FORCE;
        player.jumpsUsed++;
        playBeep("jump");
      }
    }

    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        if (currentView === "game" && isRunning) {
          tryJump();
        } else if (currentView === "gameOver" && !isRunning) {
          startGame();
        }
      } else if (e.key === "Shift" || e.code === "ShiftLeft" || e.code === "ShiftRight") {
        if (currentView === "game" && isRunning) {
          dropRequested = true;
        }
      }
    });

    function addTapJump(target) {
      target.addEventListener(
        "touchstart",
        (e) => {
          e.preventDefault();
          if (currentView === "game" && isRunning) {
            tryJump();
          } else if (currentView === "gameOver" && !isRunning) {
            startGame();
          }
        },
        { passive: false }
      );
    }

    addTapJump(canvas);
    addTapJump(document.body);

    // BUTTONS

    document.getElementById("btnPlay").addEventListener("click", () => {
      startGame();
    });

    document
      .getElementById("btnInstructions")
      .addEventListener("click", () => {
        stopMusic();
        showView("instructions");
      });

    document.getElementById("btnBackMenu").addEventListener("click", () => {
      stopMusic();
      showView("menu");
    });

    document
      .getElementById("btnPlayFromInstructions")
      .addEventListener("click", () => {
        startGame();
      });

    document.getElementById("btnRestart").addEventListener("click", () => {
      startGame();
    });

    document.getElementById("btnGoMenu").addEventListener("click", () => {
      stopMusic();
      showView("menu");
    });
  </script>
</body>
</html>
